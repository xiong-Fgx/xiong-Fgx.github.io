<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>【笔记】数据库与MySQL | POWDER SNOW</title>
  <meta name="keywords" content=" 数据库 ">
  <meta name="description" content="【笔记】数据库与MySQL | POWDER SNOW">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta property="og:type" content="website">
<meta property="og:title" content="categories">
<meta property="og:url" content="http://yoursite.com/categories/index.html">
<meta property="og:site_name" content="POWDER SNOW">
<meta property="article:published_time" content="2018-03-02T04:33:16.000Z">
<meta property="article:modified_time" content="2020-03-05T13:28:59.839Z">
<meta property="article:author" content="冯冠雄">
<meta name="twitter:card" content="summary">


<link rel="icon" href="/img/avatar.jpg">

<link href="/css/style.css?v=1.0.1" rel="stylesheet">

<link href="/css/hl_theme/atom-light.css?v=1.0.1" rel="stylesheet">

<link href="//cdn.bootcss.com/animate.css/3.5.2/animate.min.css" rel="stylesheet">
<link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="/js/jquery.autocomplete.min.js?v=1.0.1" ></script>

<script src="//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.js"></script>



<script src="//cdn.bootcss.com/jquery-cookie/1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.0.1" ></script>

<meta name="generator" content="Hexo 4.2.0"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="false">
  <input class="theme_blog_path" value="">
</div>

<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/" class="avatar_target">
    <img class="avatar" src="/img/avatar.jpg" />
</a>
<div class="author">
    <span>冯冠雄</span>
</div>

<div class="icon">
    
        
        <a title="github" href="https://github.com/xiong-Fgx" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-github"></use>
                </svg>
            
        </a>
        
    
        
        <a title="linkedin" href="https://www.linkedin.com/in/guanxiong-feng-8b6aa8179" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-linkedin"></use>
                </svg>
            
        </a>
        
    
        
        <a title="email" href="mailto:guanxiongf@gmail.com" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-email"></use>
                </svg>
            
        </a>
        
    
</div>




<ul>
    <li><div class="all active">全部文章</div></li>
    
        
            
            <li><div data-rel="网络"><i class="fold iconfont icon-right"></i>网络</div>
                
                    <ul class="sub hide">
                        
                        <li><div data-rel="HTTP">HTTP</div>
                            
                        </li>
                            
                        <li><div data-rel="protobuf">protobuf</div>
                            
                        </li>
                            
                        <li><div data-rel="网络编程">网络编程</div>
                            
                        </li>
                            
                    </ul>
                
            </li>
            
        
    
        
            
            <li><div data-rel="数据库">数据库</div>
                
            </li>
            
        
    
        
            
        
    
        
            
            <li><div data-rel="SSM"><i class="fold iconfont icon-right"></i>SSM</div>
                
                    <ul class="sub hide">
                        
                        <li><div data-rel="SSM整合">SSM整合</div>
                            
                        </li>
                            
                        <li><div data-rel="Spring">Spring</div>
                            
                        </li>
                            
                        <li><div data-rel="SpringMVC">SpringMVC</div>
                            
                        </li>
                            
                        <li><div data-rel="MyBatis">MyBatis</div>
                            
                        </li>
                            
                        <li><div data-rel="SpringBoot">SpringBoot</div>
                            
                        </li>
                            
                    </ul>
                
            </li>
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
            <li><div data-rel="客户端"><i class="fold iconfont icon-right"></i>客户端</div>
                
                    <ul class="sub hide">
                        
                        <li><div data-rel="QT">QT</div>
                            
                        </li>
                            
                    </ul>
                
            </li>
            
        
    
        
            
            <li><div data-rel="区块链"><i class="fold iconfont icon-right"></i>区块链</div>
                
                    <ul class="sub hide">
                        
                        <li><div data-rel="论文">论文</div>
                            
                        </li>
                            
                        <li><div data-rel="Fabric">Fabric</div>
                            
                        </li>
                            
                        <li><div data-rel="fabric">fabric</div>
                            
                        </li>
                            
                    </ul>
                
            </li>
            
        
    
        
            
            <li><div data-rel="分布式">分布式</div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="大数据"><i class="fold iconfont icon-right"></i>大数据</div>
                
                    <ul class="sub hide">
                        
                        <li><div data-rel="hadoop">hadoop</div>
                            
                        </li>
                            
                    </ul>
                
            </li>
            
        
    
        
            
            <li><div data-rel="前端"><i class="fold iconfont icon-right"></i>前端</div>
                
                    <ul class="sub hide">
                        
                        <li><div data-rel="HTML">HTML</div>
                            
                        </li>
                            
                        <li><div data-rel="CSS">CSS</div>
                            
                        </li>
                            
                    </ul>
                
            </li>
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
            <li><div data-rel="笔记">笔记</div>
                
            </li>
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
    
    
    
    
    </div>
    <div></div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="71">

<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        友情链接
        <i class="back-title-list"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="http://yelog.org/">叶落阁</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <form onkeydown="if(event.keyCode === 13){return false;}">
        <input id="local-search-input" class="search" type="text" placeholder="Search..." />
        <i class="cross"></i>
        <span>
            <label for="tagswitch">Tags:</label>
            <input id="tagswitch" type="checkbox" style="display: none" />
            <i id="tagsWitchIcon"></i>
        </span>
    </form>
    <div class="tags-list">
    
    <li class="article-tag-list-item">
        <a class="color5">HTTP</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color4">protobuf</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color5">MySQL SQL</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color2">Spring</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color5">java</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color3">QT</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color4">区块链</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color4">分布式</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color4">大数据</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color3">前端</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color3">MyBatis</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color1">SpringBoot</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color5">网络编程</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color1">Redis</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color4">多线程</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color4">数据库</a>
    </li>
    
    <div class="clearfix"></div>
</div>

    
    <nav id="title-list-nav">
        
        <a  class="前端 CSS "
           href="/2021/01/11/html/4_%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/"
           data-tag="前端"
           data-author="" >
            <span class="post-title" title="【前端 4】盒子模型">【前端 4】盒子模型</span>
            <span class="post-date" title="2021-01-11 09:41:10">2021/01/11</span>
        </a>
        
        <a  class="前端 CSS "
           href="/2021/01/09/html/3_CSS%E8%BF%9B%E9%98%B6/"
           data-tag="前端"
           data-author="" >
            <span class="post-title" title="【前端 3】CSS进阶">【前端 3】CSS进阶</span>
            <span class="post-date" title="2021-01-09 09:43:10">2021/01/09</span>
        </a>
        
        <a  class="前端 CSS "
           href="/2021/01/05/html/2_CSS/"
           data-tag="前端"
           data-author="" >
            <span class="post-title" title="【前端 2】CSS">【前端 2】CSS</span>
            <span class="post-date" title="2021-01-05 16:22:10">2021/01/05</span>
        </a>
        
        <a  class="前端 HTML "
           href="/2021/01/04/html/1_html/"
           data-tag="前端"
           data-author="" >
            <span class="post-title" title="【前端 1】HTML">【前端 1】HTML</span>
            <span class="post-date" title="2021-01-04 10:46:10">2021/01/04</span>
        </a>
        
        <a  class="区块链 fabric "
           href="/2020/12/12/fabric/08_%E9%93%BE%E7%A0%81/"
           data-tag="区块链"
           data-author="" >
            <span class="post-title" title="07_链码接口使用">07_链码接口使用</span>
            <span class="post-date" title="2020-12-12 11:43:23">2020/12/12</span>
        </a>
        
        <a  class="区块链 fabric "
           href="/2020/12/12/fabric/02_%E9%83%A8%E7%BD%B2%E8%B0%83%E7%94%A8%E9%93%BE%E7%A0%81/"
           data-tag="区块链"
           data-author="" >
            <span class="post-title" title="02_部署调用链码">02_部署调用链码</span>
            <span class="post-date" title="2020-12-12 10:56:23">2020/12/12</span>
        </a>
        
        <a  class="区块链 fabric "
           href="/2020/12/09/fabric/07_dockerCompose%E5%90%AF%E5%8A%A8fabric/"
           data-tag="区块链"
           data-author="" >
            <span class="post-title" title="06_docker compose启动节点">06_docker compose启动节点</span>
            <span class="post-date" title="2020-12-09 11:35:23">2020/12/09</span>
        </a>
        
        <a  class="区块链 fabric "
           href="/2020/12/09/fabric/03_%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84%E5%8F%98%E5%8A%A8/"
           data-tag="区块链"
           data-author="" >
            <span class="post-title" title="03_用户结构变动">03_用户结构变动</span>
            <span class="post-date" title="2020-12-09 10:35:23">2020/12/09</span>
        </a>
        
        <a  class="区块链 fabric "
           href="/2020/12/02/fabric/01_%E6%90%AD%E5%BB%BA%E5%9F%BA%E7%A1%80%E7%BD%91%E7%BB%9C/"
           data-tag="区块链"
           data-author="" >
            <span class="post-title" title="01_搭建基础网络">01_搭建基础网络</span>
            <span class="post-date" title="2020-12-02 11:05:23">2020/12/02</span>
        </a>
        
        <a  class="区块链 fabric "
           href="/2020/12/01/fabric/05_java%20SDK%E4%BD%BF%E7%94%A8/"
           data-tag="区块链"
           data-author="" >
            <span class="post-title" title="05_javaSDK使用">05_javaSDK使用</span>
            <span class="post-date" title="2020-12-01 15:04:23">2020/12/01</span>
        </a>
        
        <a  class="区块链 fabric "
           href="/2020/12/01/fabric/04_%E7%94%A8%E6%88%B7%E4%BD%BF%E7%94%A8%E9%93%BE%E7%A0%81/"
           data-tag="区块链"
           data-author="" >
            <span class="post-title" title="04_用户使用链码">04_用户使用链码</span>
            <span class="post-date" title="2020-12-01 10:55:23">2020/12/01</span>
        </a>
        
        <a  class="大数据 hadoop "
           href="/2020/11/26/hadoop/%E5%AE%89%E8%A3%85/"
           data-tag="大数据"
           data-author="" >
            <span class="post-title" title="【hadoop 3】hadoop分布式安装总结">【hadoop 3】hadoop分布式安装总结</span>
            <span class="post-date" title="2020-11-26 17:50:09">2020/11/26</span>
        </a>
        
        <a  class="客户端 QT "
           href="/2020/10/29/QT/4_%E6%A8%A1%E5%9E%8B%20%E8%A7%86%E5%9B%BE%E7%BB%93%E6%9E%84/"
           data-tag="QT"
           data-author="" >
            <span class="post-title" title="【QT 3】模型-视图结构">【QT 3】模型-视图结构</span>
            <span class="post-date" title="2020-10-29 16:49:10">2020/10/29</span>
        </a>
        
        <a  class="客户端 QT "
           href="/2020/10/28/QT/3_%E6%8E%A7%E4%BB%B6/"
           data-tag="QT"
           data-author="" >
            <span class="post-title" title="【QT 2】控件">【QT 2】控件</span>
            <span class="post-date" title="2020-10-28 16:55:10">2020/10/28</span>
        </a>
        
        <a  class="客户端 QT "
           href="/2020/10/28/QT/2_%E5%B8%83%E5%B1%80%E7%AE%A1%E7%90%86/"
           data-tag="QT"
           data-author="" >
            <span class="post-title" title="【QT 1】布局管理">【QT 1】布局管理</span>
            <span class="post-date" title="2020-10-28 14:37:10">2020/10/28</span>
        </a>
        
        <a  class="客户端 QT "
           href="/2020/10/20/QT/QT%E7%95%8C%E9%9D%A2%E7%BC%96%E8%BE%91%E5%99%A8/"
           data-tag="QT"
           data-author="" >
            <span class="post-title" title="【QT 4】QT界面编辑器">【QT 4】QT界面编辑器</span>
            <span class="post-date" title="2020-10-20 15:52:10">2020/10/20</span>
        </a>
        
        <a  class="SSM Spring "
           href="/2020/06/01/%E7%AC%94%E8%AE%B0/spring/"
           data-tag="Spring"
           data-author="" >
            <span class="post-title" title="【笔记】Spring总结">【笔记】Spring总结</span>
            <span class="post-date" title="2020-06-01 03:57:17">2020/06/01</span>
        </a>
        
        <a  class="笔记 "
           href="/2020/05/12/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93/"
           data-tag="数据库"
           data-author="" >
            <span class="post-title" title="【笔记】数据库与MySQL">【笔记】数据库与MySQL</span>
            <span class="post-date" title="2020-05-12 21:38:05">2020/05/12</span>
        </a>
        
        <a  class="笔记 "
           href="/2020/05/07/%E7%AC%94%E8%AE%B0/redis/"
           data-tag="Redis"
           data-author="" >
            <span class="post-title" title="【笔记】Redis">【笔记】Redis</span>
            <span class="post-date" title="2020-05-07 18:38:05">2020/05/07</span>
        </a>
        
        <a  class="笔记 "
           href="/2020/04/25/%E7%AC%94%E8%AE%B0/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"
           data-tag="多线程"
           data-author="" >
            <span class="post-title" title="【笔记】java并发">【笔记】java并发</span>
            <span class="post-date" title="2020-04-25 15:38:01">2020/04/25</span>
        </a>
        
        <a  class="大数据 hadoop "
           href="/2020/03/18/hadoop/2_%E4%BD%BF%E7%94%A8hadoop/"
           data-tag="大数据"
           data-author="" >
            <span class="post-title" title="【hadoop 2】hadoop三种模式使用">【hadoop 2】hadoop三种模式使用</span>
            <span class="post-date" title="2020-03-18 17:49:04">2020/03/18</span>
        </a>
        
        <a  class="SSM SpringBoot "
           href="/2020/03/18/springboot/3_springboot%E7%9A%84%E9%85%8D%E7%BD%AE/"
           data-tag="SpringBoot"
           data-author="" >
            <span class="post-title" title="【SpringBoot 02】配置文件">【SpringBoot 02】配置文件</span>
            <span class="post-date" title="2020-03-18 12:58:23">2020/03/18</span>
        </a>
        
        <a  class="SSM SpringBoot "
           href="/2020/03/17/springboot/2_springboot%E7%9A%84helloworld/"
           data-tag="SpringBoot"
           data-author="" >
            <span class="post-title" title="【SpringBoot 01】HelloWorld">【SpringBoot 01】HelloWorld</span>
            <span class="post-date" title="2020-03-17 19:58:23">2020/03/17</span>
        </a>
        
        <a  class="SSM SSM整合 "
           href="/2020/03/05/3-SpringMVC/1_%E6%90%AD%E5%BB%BAspring/"
           data-tag="java"
           data-author="" >
            <span class="post-title" title="【SSM实战】SSM框架整合">【SSM实战】SSM框架整合</span>
            <span class="post-date" title="2020-03-05 20:37:01">2020/03/05</span>
        </a>
        
        <a  class="SSM SpringMVC "
           href="/2020/03/05/3-SpringMVC/7_SpringMVC%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E4%B8%8E%E6%8B%A6%E6%88%AA%E5%99%A8/"
           data-tag="java"
           data-author="" >
            <span class="post-title" title="【SpringMVC实战6】异常处理与拦截器">【SpringMVC实战6】异常处理与拦截器</span>
            <span class="post-date" title="2020-03-05 13:06:19">2020/03/05</span>
        </a>
        
        <a  class="SSM SpringMVC "
           href="/2020/03/04/3-SpringMVC/6_SpringMVC%E5%93%8D%E5%BA%94/"
           data-tag="java"
           data-author="" >
            <span class="post-title" title="【SpringMVC实战5】响应">【SpringMVC实战5】响应</span>
            <span class="post-date" title="2020-03-04 19:26:39">2020/03/04</span>
        </a>
        
        <a  class="SSM SpringMVC "
           href="/2020/03/03/3-SpringMVC/4_SpringMVC%E7%9A%84%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/"
           data-tag="java"
           data-author="" >
            <span class="post-title" title="【SpringMVC实战3】常用注解">【SpringMVC实战3】常用注解</span>
            <span class="post-date" title="2020-03-03 15:26:29">2020/03/03</span>
        </a>
        
        <a  class="SSM SpringMVC "
           href="/2020/03/03/3-SpringMVC/5_%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E7%BB%91%E5%AE%9A/"
           data-tag="java"
           data-author="" >
            <span class="post-title" title="【SpringMVC实战4】请求参数绑定">【SpringMVC实战4】请求参数绑定</span>
            <span class="post-date" title="2020-03-03 09:13:23">2020/03/03</span>
        </a>
        
        <a  class="SSM SpringMVC "
           href="/2020/03/02/3-SpringMVC/3_SpringMVC%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/"
           data-tag="java"
           data-author="" >
            <span class="post-title" title="【SpringMVC实战2】执行流程">【SpringMVC实战2】执行流程</span>
            <span class="post-date" title="2020-03-02 18:26:39">2020/03/02</span>
        </a>
        
        <a  class="SSM SpringMVC "
           href="/2020/03/02/3-SpringMVC/2_%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B/"
           data-tag="java"
           data-author="" >
            <span class="post-title" title="【SpringMVC实战1】入门案例">【SpringMVC实战1】入门案例</span>
            <span class="post-date" title="2020-03-02 14:26:39">2020/03/02</span>
        </a>
        
        <a  class="SSM Spring "
           href="/2020/02/21/13-Spring/8_%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6/"
           data-tag="Spring"
           data-author="" >
            <span class="post-title" title="【Spring实战8】事务控制">【Spring实战8】事务控制</span>
            <span class="post-date" title="2020-02-21 15:23:48">2020/02/21</span>
        </a>
        
        <a  class="SSM Spring "
           href="/2020/02/20/13-Spring/7_JdbcTemplate/"
           data-tag="Spring"
           data-author="" >
            <span class="post-title" title="【Spring实战7】JdbcTemplate">【Spring实战7】JdbcTemplate</span>
            <span class="post-date" title="2020-02-20 09:32:29">2020/02/20</span>
        </a>
        
        <a  class="SSM Spring "
           href="/2020/02/19/13-Spring/6_%E5%9F%BA%E4%BA%8Exml%E5%92%8C%E6%B3%A8%E8%A7%A3%E7%9A%84AOP%E9%85%8D%E7%BD%AE/"
           data-tag="Spring"
           data-author="" >
            <span class="post-title" title="【Spring实战6】基于xml和注解的AOP配置">【Spring实战6】基于xml和注解的AOP配置</span>
            <span class="post-date" title="2020-02-19 21:31:44">2020/02/19</span>
        </a>
        
        <a  class="SSM Spring "
           href="/2020/02/19/13-Spring/5_AOP/"
           data-tag="Spring"
           data-author="" >
            <span class="post-title" title="【Spring实战5】AOP">【Spring实战5】AOP</span>
            <span class="post-date" title="2020-02-19 18:56:47">2020/02/19</span>
        </a>
        
        <a  class="SSM Spring "
           href="/2020/02/18/13-Spring/4_%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"
           data-tag="Spring"
           data-author="" >
            <span class="post-title" title="【Spring实战4】动态代理">【Spring实战4】动态代理</span>
            <span class="post-date" title="2020-02-18 17:15:32">2020/02/18</span>
        </a>
        
        <a  class="SSM Spring "
           href="/2020/02/14/13-Spring/3_%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E7%9A%84IOC/"
           data-tag="Spring"
           data-author="" >
            <span class="post-title" title="【Spring实战3】IoC注解">【Spring实战3】IoC注解</span>
            <span class="post-date" title="2020-02-14 20:57:17">2020/02/14</span>
        </a>
        
        <a  class="SSM Spring "
           href="/2020/02/13/13-Spring/2_IOC/"
           data-tag="Spring"
           data-author="" >
            <span class="post-title" title="【Spring实战2】IoC与DI">【Spring实战2】IoC与DI</span>
            <span class="post-date" title="2020-02-13 20:56:03">2020/02/13</span>
        </a>
        
        <a  class="SSM Spring "
           href="/2020/02/13/13-Spring/1_%E7%A8%8B%E5%BA%8F%E8%80%A6%E5%90%88%E4%B8%8E%E8%A7%A3%E8%80%A6/"
           data-tag="Spring"
           data-author="" >
            <span class="post-title" title="【Spring实战1】程序的耦合与解耦">【Spring实战1】程序的耦合与解耦</span>
            <span class="post-date" title="2020-02-13 13:17:03">2020/02/13</span>
        </a>
        
        <a  class="SSM MyBatis "
           href="/2020/02/07/mybatis/10_%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91/"
           data-tag="MyBatis"
           data-author="" >
            <span class="post-title" title="【Mybatis实战5】注解开发">【Mybatis实战5】注解开发</span>
            <span class="post-date" title="2020-02-07 16:18:37">2020/02/07</span>
        </a>
        
        <a  class="SSM MyBatis "
           href="/2020/02/06/mybatis/9_%E7%BC%93%E5%AD%98/"
           data-tag="MyBatis"
           data-author="" >
            <span class="post-title" title="【Mybatis实战4】加载与缓存">【Mybatis实战4】加载与缓存</span>
            <span class="post-date" title="2020-02-06 18:29:03">2020/02/06</span>
        </a>
        
        <a  class="SSM MyBatis "
           href="/2020/02/06/mybatis/8_%E5%8A%A8%E6%80%81SQL%E4%B8%8E%E5%A4%9A%E8%A1%A8%E6%93%8D%E4%BD%9C/"
           data-tag="MyBatis"
           data-author="" >
            <span class="post-title" title="【Mybatis实战3】动态SQL与多表操作">【Mybatis实战3】动态SQL与多表操作</span>
            <span class="post-date" title="2020-02-06 18:08:29">2020/02/06</span>
        </a>
        
        <a  class="SSM MyBatis "
           href="/2020/02/06/mybatis/6_mybatis%E8%BF%9B%E8%A1%8CCRUD/"
           data-tag="MyBatis"
           data-author="" >
            <span class="post-title" title="【Mybatis实战2】CRUD操作">【Mybatis实战2】CRUD操作</span>
            <span class="post-date" title="2020-02-06 13:21:03">2020/02/06</span>
        </a>
        
        <a  class="SSM MyBatis "
           href="/2020/02/05/mybatis/2_%E5%9F%BA%E4%BA%8Exml%E7%9A%84%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"
           data-tag="MyBatis"
           data-author="" >
            <span class="post-title" title="【Mybatis实战1】两种环境搭建方法及示例">【Mybatis实战1】两种环境搭建方法及示例</span>
            <span class="post-date" title="2020-02-05 10:21:01">2020/02/05</span>
        </a>
        
        <a  class="数据库 "
           href="/2020/01/29/11-MySQL/3_%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2%E4%B8%8E%E4%BA%8B%E5%8A%A1/"
           data-tag="MySQL SQL"
           data-author="" >
            <span class="post-title" title="多表查询与事务">多表查询与事务</span>
            <span class="post-date" title="2020-01-29 13:52:00">2020/01/29</span>
        </a>
        
        <a  class="数据库 "
           href="/2020/01/26/11-MySQL/2_SQL%E9%AB%98%E7%BA%A7/"
           data-tag="MySQL SQL"
           data-author="" >
            <span class="post-title" title="数据库高级知识及SQL实现">数据库高级知识及SQL实现</span>
            <span class="post-date" title="2020-01-26 23:01:52">2020/01/26</span>
        </a>
        
        <a  class="数据库 "
           href="/2020/01/23/11-MySQL/1_SQL%E8%AF%AD%E8%A8%80%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"
           data-tag="MySQL SQL"
           data-author="" >
            <span class="post-title" title="SQL语言基础">SQL语言基础</span>
            <span class="post-date" title="2020-01-23 20:06:39">2020/01/23</span>
        </a>
        
        <a  class="网络 protobuf "
           href="/2020/01/16/10-java%E7%BD%91%E7%BB%9C/2_protobuf/"
           data-tag="protobuf"
           data-author="" >
            <span class="post-title" title="java使用protobuf">java使用protobuf</span>
            <span class="post-date" title="2020-01-16 17:57:52">2020/01/16</span>
        </a>
        
        <a  class="网络 HTTP "
           href="/2020/01/15/10-java%E7%BD%91%E7%BB%9C/1_HTTP/"
           data-tag="HTTP"
           data-author="" >
            <span class="post-title" title="java实现简单的HTTP">java实现简单的HTTP</span>
            <span class="post-date" title="2020-01-15 18:03:21">2020/01/15</span>
        </a>
        
        <a  class="大数据 hadoop "
           href="/2020/01/06/hadoop/1_hadoop/"
           data-tag="大数据"
           data-author="" >
            <span class="post-title" title="【hadoop 1】hadoop环境搭建">【hadoop 1】hadoop环境搭建</span>
            <span class="post-date" title="2020-01-06 14:55:10">2020/01/06</span>
        </a>
        
        <a  class="区块链 Fabric "
           href="/2019/11/24/blockchain/09/"
           data-tag="区块链"
           data-author="" >
            <span class="post-title" title="Hyperledger Fabric系统框架笔记">Hyperledger Fabric系统框架笔记</span>
            <span class="post-date" title="2019-11-24 12:43:08">2019/11/24</span>
        </a>
        
        <a  class="区块链 论文 "
           href="/2019/11/21/blockchain/08/"
           data-tag="区块链"
           data-author="" >
            <span class="post-title" title="闪电网络（四）比特币闪电网络：The Bitcoin Lightning Network">闪电网络（四）比特币闪电网络：The Bitcoin Lightning Network</span>
            <span class="post-date" title="2019-11-21 21:31:53">2019/11/21</span>
        </a>
        
        <a  class="区块链 论文 "
           href="/2019/11/20/blockchain/07/"
           data-tag="区块链"
           data-author="" >
            <span class="post-title" title="闪电网络（三）哈希时间锁合约：Hashed Timelock Contract (HTLC)">闪电网络（三）哈希时间锁合约：Hashed Timelock Contract (HTLC)</span>
            <span class="post-date" title="2019-11-20 10:51:23">2019/11/20</span>
        </a>
        
        <a  class="区块链 论文 "
           href="/2019/11/20/blockchain/05/"
           data-tag="区块链"
           data-author="" >
            <span class="post-title" title="闪电网络（二）双向支付通道：Bidirectional Payment Channels + RSMC">闪电网络（二）双向支付通道：Bidirectional Payment Channels + RSMC</span>
            <span class="post-date" title="2019-11-20 10:51:23">2019/11/20</span>
        </a>
        
        <a  class="区块链 论文 "
           href="/2019/11/19/blockchain/06/"
           data-tag="区块链"
           data-author="" >
            <span class="post-title" title="闪电网络（一）微支付通道">闪电网络（一）微支付通道</span>
            <span class="post-date" title="2019-11-19 10:07:02">2019/11/19</span>
        </a>
        
        <a  class="区块链 论文 "
           href="/2019/11/15/blockchain/03/"
           data-tag="区块链"
           data-author="" >
            <span class="post-title" title="论文翻译 OmniLedger">论文翻译 OmniLedger</span>
            <span class="post-date" title="2019-11-15 16:15:33">2019/11/15</span>
        </a>
        
        <a  class="网络 网络编程 "
           href="/2019/11/03/networkProgram/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B10UDP%E8%BF%9E%E6%8E%A5/"
           data-tag="网络编程"
           data-author="" >
            <span class="post-title" title="网络编程10：UDP连接">网络编程10：UDP连接</span>
            <span class="post-date" title="2019-11-03 16:15:07">2019/11/03</span>
        </a>
        
        <a  class="网络 网络编程 "
           href="/2019/11/02/networkProgram/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B9TCP%E7%9A%84%E5%BC%82%E5%B8%B8/"
           data-tag="网络编程"
           data-author="" >
            <span class="post-title" title="网络编程9：TCP的异常">网络编程9：TCP的异常</span>
            <span class="post-date" title="2019-11-02 13:57:10">2019/11/02</span>
        </a>
        
        <a  class="网络 网络编程 "
           href="/2019/11/01/networkProgram/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B8TCP%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93/"
           data-tag="网络编程"
           data-author="" >
            <span class="post-title" title="网络编程8：TCP数据传输">网络编程8：TCP数据传输</span>
            <span class="post-date" title="2019-11-01 18:34:10">2019/11/01</span>
        </a>
        
        <a  class="网络 网络编程 "
           href="/2019/10/31/networkProgram/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B7TCP%E8%BF%9E%E6%8E%A5%E7%8A%B6%E6%80%81/"
           data-tag="网络编程"
           data-author="" >
            <span class="post-title" title="网络编程7：TCP连接状态">网络编程7：TCP连接状态</span>
            <span class="post-date" title="2019-10-31 17:14:55">2019/10/31</span>
        </a>
        
        <a  class="网络 网络编程 "
           href="/2019/10/30/networkProgram/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B6%E5%85%B3%E9%97%AD%E8%BF%9E%E6%8E%A5/"
           data-tag="网络编程"
           data-author="" >
            <span class="post-title" title="网络编程6：关闭连接">网络编程6：关闭连接</span>
            <span class="post-date" title="2019-10-30 18:34:12">2019/10/30</span>
        </a>
        
        <a  class="网络 网络编程 "
           href="/2019/10/29/networkProgram/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B5%E7%BD%91%E7%BB%9C%E5%B7%A5%E5%85%B7/"
           data-tag="网络编程"
           data-author="" >
            <span class="post-title" title="网络编程5：网络工具">网络编程5：网络工具</span>
            <span class="post-date" title="2019-10-29 14:24:11">2019/10/29</span>
        </a>
        
        <a  class="网络 网络编程 "
           href="/2019/10/28/networkProgram/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B3UDP%E5%8D%8F%E8%AE%AE%E4%BD%BF%E7%94%A8socket/"
           data-tag="网络编程"
           data-author="" >
            <span class="post-title" title="网络编程3：UDP协议使用socket">网络编程3：UDP协议使用socket</span>
            <span class="post-date" title="2019-10-28 10:11:10">2019/10/28</span>
        </a>
        
        <a  class="网络 网络编程 "
           href="/2019/10/28/networkProgram/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B4%E6%9C%AC%E5%9C%B0socket/"
           data-tag="网络编程"
           data-author="" >
            <span class="post-title" title="网络编程4：本地套接字">网络编程4：本地套接字</span>
            <span class="post-date" title="2019-10-28 10:11:10">2019/10/28</span>
        </a>
        
        <a  class="网络 网络编程 "
           href="/2019/10/27/networkProgram/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B2TCP%E5%8D%8F%E8%AE%AE%E4%BD%BF%E7%94%A8socket/"
           data-tag="网络编程"
           data-author="" >
            <span class="post-title" title="网络编程2：TCP协议使用socket">网络编程2：TCP协议使用socket</span>
            <span class="post-date" title="2019-10-27 17:59:09">2019/10/27</span>
        </a>
        
        <a  class="网络 网络编程 "
           href="/2019/10/26/networkProgram/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B1/"
           data-tag="网络编程"
           data-author="" >
            <span class="post-title" title="网络编程1：基础部分">网络编程1：基础部分</span>
            <span class="post-date" title="2019-10-26 16:54:02">2019/10/26</span>
        </a>
        
        <a  class="分布式 "
           href="/2019/09/12/distribute/01/"
           data-tag="分布式"
           data-author="" >
            <span class="post-title" title="分布式系统的一致性与共识">分布式系统的一致性与共识</span>
            <span class="post-date" title="2019-09-12 13:47:52">2019/09/12</span>
        </a>
        
        <a  class="网络 HTTP "
           href="/2019/08/05/http/030205/"
           data-tag="HTTP"
           data-author="" >
            <span class="post-title" title="HTTP协议学习（五）HTTPS与安全">HTTP协议学习（五）HTTPS与安全</span>
            <span class="post-date" title="2019-08-05 20:46:07">2019/08/05</span>
        </a>
        
        <a  class="网络 HTTP "
           href="/2019/07/20/http/030204/"
           data-tag="HTTP"
           data-author="" >
            <span class="post-title" title="HTTP协议学习（四）cookie、缓存、代理机制">HTTP协议学习（四）cookie、缓存、代理机制</span>
            <span class="post-date" title="2019-07-20 13:15:07">2019/07/20</span>
        </a>
        
        <a  class="网络 HTTP "
           href="/2019/07/10/http/030203/"
           data-tag="HTTP"
           data-author="" >
            <span class="post-title" title="HTTP协议学习（三）数据传输与连接">HTTP协议学习（三）数据传输与连接</span>
            <span class="post-date" title="2019-07-10 14:36:55">2019/07/10</span>
        </a>
        
        <a  class="网络 HTTP "
           href="/2019/07/01/http/030202/"
           data-tag="HTTP"
           data-author="" >
            <span class="post-title" title="HTTP协议学习（二）基础">HTTP协议学习（二）基础</span>
            <span class="post-date" title="2019-07-01 14:05:51">2019/07/01</span>
        </a>
        
        <a  class="网络 HTTP "
           href="/2019/06/14/http/030201/"
           data-tag="HTTP"
           data-author="" >
            <span class="post-title" title="HTTP协议学习（一）概念">HTTP协议学习（一）概念</span>
            <span class="post-date" title="2019-06-14 16:08:25">2019/06/14</span>
        </a>
        
    </nav>
</div>
    </div>
    <div class="hide-list">
        <div class="semicircle">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div class="post">
    <div class="pjax">
        <article id="post-笔记/数据库" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">【笔记】数据库与MySQL</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            
                <a  data-rel="笔记">笔记</a>
            
        </span>
        
        
        <span class="tag">
            
            <a class="color4">数据库</a>
            
        </span>
        
    </div>
    <div class="article-meta">
        
        创建时间:<time class="date" title='更新时间: 2020-06-15 10:30:29'>2020-05-12 21:38</time>
        
    </div>
    <div class="article-meta">
        
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#数据库"><span class="toc-text">数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-java如何访问数据库"><span class="toc-text">1. java如何访问数据库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-数据库连接池"><span class="toc-text">2. 数据库连接池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-SQL执行流程"><span class="toc-text">3. SQL执行流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-查询语句"><span class="toc-text">3.1 查询语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-更新语句"><span class="toc-text">3.2 更新语句</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a-为什么redo-log的更新需要两阶段提交？"><span class="toc-text">a. 为什么redo log的更新需要两阶段提交？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b-redo-log和bin-log的区别："><span class="toc-text">b. redo log和bin log的区别：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-MySQL中的结构"><span class="toc-text">4. MySQL中的结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-缓冲池（Buffer-Pool）"><span class="toc-text">4.1 缓冲池（Buffer Pool）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-undo-Log"><span class="toc-text">4.2 undo Log</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-redo-Log"><span class="toc-text">4.3 redo Log</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-bin-log"><span class="toc-text">4.4 bin log</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SQL"><span class="toc-text">SQL</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-几种join"><span class="toc-text">1. 几种join</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#数据库三范式"><span class="toc-text">数据库三范式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#事务"><span class="toc-text">事务</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-事务的ACID特性"><span class="toc-text">1. 事务的ACID特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-事务隔离级别与三大问题"><span class="toc-text">2. 事务隔离级别与三大问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-三大问题"><span class="toc-text">2.1 三大问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-四大隔离级别"><span class="toc-text">2.2 四大隔离级别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-隔离级别的实现"><span class="toc-text">3. 隔离级别的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-事务的启动方式"><span class="toc-text">4. 事务的启动方式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#当前读与快照读"><span class="toc-text">当前读与快照读</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-定义"><span class="toc-text">1. 定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-RR当前读、快照读的幻读解决"><span class="toc-text">2. RR当前读、快照读的幻读解决</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#锁"><span class="toc-text">锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-共享锁与排它锁"><span class="toc-text">1. 共享锁与排它锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-全局锁、表锁与行锁"><span class="toc-text">2. 全局锁、表锁与行锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-意向锁"><span class="toc-text">3. 意向锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-间隙锁-Gap-Lock、Next-Key-Lock"><span class="toc-text">4. 间隙锁 (Gap Lock、Next-Key Lock)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-何时加锁"><span class="toc-text">5. 何时加锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-死锁"><span class="toc-text">6. 死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-死锁的解决"><span class="toc-text">6.1 死锁的解决</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MVCC"><span class="toc-text">MVCC</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#0-乐观锁与悲观锁"><span class="toc-text">0. 乐观锁与悲观锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-UndoLog回滚日志"><span class="toc-text">1. UndoLog回滚日志</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-ReadView"><span class="toc-text">2. ReadView</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-ReadView实现RC与RR"><span class="toc-text">3. ReadView实现RC与RR</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-RC"><span class="toc-text">3.1 RC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-RR"><span class="toc-text">3.2 RR</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-MVCC的原理"><span class="toc-text">4. MVCC的原理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#InnoDB"><span class="toc-text">InnoDB</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-行锁的三种实现方式"><span class="toc-text">1. 行锁的三种实现方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-对比InnoDB和MyISAM"><span class="toc-text">2. 对比InnoDB和MyISAM</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#B-树"><span class="toc-text">B+树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-B树"><span class="toc-text">1. B树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-B-树"><span class="toc-text">2. B+树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-对比B-树和B树"><span class="toc-text">3. 对比B+树和B树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-对比B-树和红黑树-平衡树"><span class="toc-text">4. 对比B+树和红黑树&#x2F;平衡树</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#索引"><span class="toc-text">索引</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-索引的优劣势"><span class="toc-text">1. 索引的优劣势</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-索引的分类"><span class="toc-text">2. 索引的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-hash索引"><span class="toc-text">2.1 hash索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-聚集索引与普通索引"><span class="toc-text">2.2 聚集索引与普通索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-覆盖索引"><span class="toc-text">2.3 覆盖索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-唯一索引和普通索引"><span class="toc-text">2.4 唯一索引和普通索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-前缀索引"><span class="toc-text">2.5 前缀索引</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-最左前缀原则"><span class="toc-text">3. 最左前缀原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-索引下推"><span class="toc-text">4. 索引下推</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MySQL优化"><span class="toc-text">MySQL优化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-总体思路"><span class="toc-text">1. 总体思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-explain"><span class="toc-text">2. explain</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-索引优化"><span class="toc-text">1. 索引优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-查询优化"><span class="toc-text">2. 查询优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-优化例子1"><span class="toc-text">3. 优化例子1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-优化例子2"><span class="toc-text">4. 优化例子2</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#分库分表（高并发层面数据库应该如何设计）"><span class="toc-text">分库分表（高并发层面数据库应该如何设计）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-分库"><span class="toc-text">1. 分库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-分表"><span class="toc-text">2. 分表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-水平拆分与垂直拆分"><span class="toc-text">3. 水平拆分与垂直拆分</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#读写分离"><span class="toc-text">读写分离</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-主从复制过程"><span class="toc-text">1. 主从复制过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-主从同步延时问题"><span class="toc-text">2. 主从同步延时问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-主库宕机问题"><span class="toc-text">3. 主库宕机问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#数据类型"><span class="toc-text">数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-char与varchar的区别"><span class="toc-text">1. char与varchar的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-一行数据中的多个NULL字段在磁盘如何存储"><span class="toc-text">2. 一行数据中的多个NULL字段在磁盘如何存储</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#热备份和冷备份"><span class="toc-text">热备份和冷备份</span></a></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><div class='inner-toc'><h2>目录</h2><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#数据库"><span class="toc-text">数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-java如何访问数据库"><span class="toc-text">1. java如何访问数据库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-数据库连接池"><span class="toc-text">2. 数据库连接池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-SQL执行流程"><span class="toc-text">3. SQL执行流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-查询语句"><span class="toc-text">3.1 查询语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-更新语句"><span class="toc-text">3.2 更新语句</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a-为什么redo-log的更新需要两阶段提交？"><span class="toc-text">a. 为什么redo log的更新需要两阶段提交？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b-redo-log和bin-log的区别："><span class="toc-text">b. redo log和bin log的区别：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-MySQL中的结构"><span class="toc-text">4. MySQL中的结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-缓冲池（Buffer-Pool）"><span class="toc-text">4.1 缓冲池（Buffer Pool）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-undo-Log"><span class="toc-text">4.2 undo Log</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-redo-Log"><span class="toc-text">4.3 redo Log</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-bin-log"><span class="toc-text">4.4 bin log</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SQL"><span class="toc-text">SQL</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-几种join"><span class="toc-text">1. 几种join</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#数据库三范式"><span class="toc-text">数据库三范式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#事务"><span class="toc-text">事务</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-事务的ACID特性"><span class="toc-text">1. 事务的ACID特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-事务隔离级别与三大问题"><span class="toc-text">2. 事务隔离级别与三大问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-三大问题"><span class="toc-text">2.1 三大问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-四大隔离级别"><span class="toc-text">2.2 四大隔离级别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-隔离级别的实现"><span class="toc-text">3. 隔离级别的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-事务的启动方式"><span class="toc-text">4. 事务的启动方式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#当前读与快照读"><span class="toc-text">当前读与快照读</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-定义"><span class="toc-text">1. 定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-RR当前读、快照读的幻读解决"><span class="toc-text">2. RR当前读、快照读的幻读解决</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#锁"><span class="toc-text">锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-共享锁与排它锁"><span class="toc-text">1. 共享锁与排它锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-全局锁、表锁与行锁"><span class="toc-text">2. 全局锁、表锁与行锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-意向锁"><span class="toc-text">3. 意向锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-间隙锁-Gap-Lock、Next-Key-Lock"><span class="toc-text">4. 间隙锁 (Gap Lock、Next-Key Lock)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-何时加锁"><span class="toc-text">5. 何时加锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-死锁"><span class="toc-text">6. 死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-死锁的解决"><span class="toc-text">6.1 死锁的解决</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MVCC"><span class="toc-text">MVCC</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#0-乐观锁与悲观锁"><span class="toc-text">0. 乐观锁与悲观锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-UndoLog回滚日志"><span class="toc-text">1. UndoLog回滚日志</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-ReadView"><span class="toc-text">2. ReadView</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-ReadView实现RC与RR"><span class="toc-text">3. ReadView实现RC与RR</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-RC"><span class="toc-text">3.1 RC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-RR"><span class="toc-text">3.2 RR</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-MVCC的原理"><span class="toc-text">4. MVCC的原理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#InnoDB"><span class="toc-text">InnoDB</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-行锁的三种实现方式"><span class="toc-text">1. 行锁的三种实现方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-对比InnoDB和MyISAM"><span class="toc-text">2. 对比InnoDB和MyISAM</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#B-树"><span class="toc-text">B+树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-B树"><span class="toc-text">1. B树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-B-树"><span class="toc-text">2. B+树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-对比B-树和B树"><span class="toc-text">3. 对比B+树和B树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-对比B-树和红黑树-平衡树"><span class="toc-text">4. 对比B+树和红黑树&#x2F;平衡树</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#索引"><span class="toc-text">索引</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-索引的优劣势"><span class="toc-text">1. 索引的优劣势</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-索引的分类"><span class="toc-text">2. 索引的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-hash索引"><span class="toc-text">2.1 hash索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-聚集索引与普通索引"><span class="toc-text">2.2 聚集索引与普通索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-覆盖索引"><span class="toc-text">2.3 覆盖索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-唯一索引和普通索引"><span class="toc-text">2.4 唯一索引和普通索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-前缀索引"><span class="toc-text">2.5 前缀索引</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-最左前缀原则"><span class="toc-text">3. 最左前缀原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-索引下推"><span class="toc-text">4. 索引下推</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MySQL优化"><span class="toc-text">MySQL优化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-总体思路"><span class="toc-text">1. 总体思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-explain"><span class="toc-text">2. explain</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-索引优化"><span class="toc-text">1. 索引优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-查询优化"><span class="toc-text">2. 查询优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-优化例子1"><span class="toc-text">3. 优化例子1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-优化例子2"><span class="toc-text">4. 优化例子2</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#分库分表（高并发层面数据库应该如何设计）"><span class="toc-text">分库分表（高并发层面数据库应该如何设计）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-分库"><span class="toc-text">1. 分库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-分表"><span class="toc-text">2. 分表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-水平拆分与垂直拆分"><span class="toc-text">3. 水平拆分与垂直拆分</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#读写分离"><span class="toc-text">读写分离</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-主从复制过程"><span class="toc-text">1. 主从复制过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-主从同步延时问题"><span class="toc-text">2. 主从同步延时问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-主库宕机问题"><span class="toc-text">3. 主库宕机问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#数据类型"><span class="toc-text">数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-char与varchar的区别"><span class="toc-text">1. char与varchar的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-一行数据中的多个NULL字段在磁盘如何存储"><span class="toc-text">2. 一行数据中的多个NULL字段在磁盘如何存储</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#热备份和冷备份"><span class="toc-text">热备份和冷备份</span></a></li></ol></div></p>
<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="1-java如何访问数据库"><a href="#1-java如何访问数据库" class="headerlink" title="1. java如何访问数据库"></a>1. java如何访问数据库</h2><p>java系统通过MySQL驱动与数据库建立网络连接，通过这个连接来执行SQL语句</p>
<h2 id="2-数据库连接池"><a href="#2-数据库连接池" class="headerlink" title="2. 数据库连接池"></a>2. 数据库连接池</h2><p>数据库连接池就是创建多个数据库的连接，这样不同的请求发过来就可以通过不同的连接来访问数据库，防止反复建立连接销毁连接导致的效率低下问题</p>
<h2 id="3-SQL执行流程"><a href="#3-SQL执行流程" class="headerlink" title="3. SQL执行流程"></a>3. SQL执行流程</h2><h3 id="3-1-查询语句"><a href="#3-1-查询语句" class="headerlink" title="3.1 查询语句"></a>3.1 查询语句</h3><p><strong>查询语句在SQL如何执行</strong></p>
<p>客户端通过连接器进行查询，先到缓存中查找是否存在结果，如果存在则直接返回查询结果，如果不存在，则进行数据库的查询操作，对SQL语句进行分析和优化之后，到存储引擎中执行查询。</p>
<ol>
<li><p><strong>建立连接</strong></p>
<p>客户端会与数据库通过连接器建立连接，长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。由于建立连接和断开连接的过程复杂，会耗费较多的时间，因此通常都使用长连接</p>
</li>
<li><p><strong>查询缓存</strong></p>
<p>建立连接完成之后，首先会去查询缓存，如果在缓存中命中了数据，则可以直接将数据返回，节省时间。但是这个查询缓存虽然可以在多次查询相同数据时能够加速查询，但是也是有弊端的，因为缓存的失效非常频繁，<strong>只要对数据表有修改，这个缓存就会失效</strong>，因此如果是对于经常更新的表，是不太适合使用缓存的。在mysql8.0之后“指定使用缓存”这个功能就被取消了，也就是不能指定去查询缓存。</p>
</li>
<li><p><strong>分析器分析</strong></p>
<p>主要就是进行词法分析和语法分析，先根据词法分析看有没有输入错误的内容，然后根据语法分析看是否满足SQL的语法规则</p>
</li>
<li><p><strong>优化器优化</strong></p>
<p>优化器是在表里面有多个索引的时候，决定使用哪个索引，再比如如果有执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。</p>
</li>
<li><p><strong>执行器执行</strong></p>
<p>要先判断一下你对这个表 T 有没有执行查询的权限，如果没有，就会返回没有权限的错误，如下所示 (在工程实现上，如果命中查询缓存，会在查询缓存返回结果的时候，做权限验证。</p>
</li>
</ol>
<p><img src="/2020/05/12/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93/image-20200611105026003.png" alt="查询的执行流程"></p>
<h3 id="3-2-更新语句"><a href="#3-2-更新语句" class="headerlink" title="3.2 更新语句"></a>3.2 更新语句</h3><p><strong>更新语句的执行过程</strong></p>
<p>简而言之，当有一条记录需要更新的时候，InnoDB 引擎就<strong>会先把记录写到 redo log里面，并更新内存</strong>，这个时候更新就算完成了。同时，InnoDB 引擎会<strong>在适当的时候，将这个操作记录更新到磁盘里面</strong>，而这个更新往往是在系统比较空闲的时候做。</p>
<p>InnoDB 的 redo log 是固定大小的，对于日志都是从头开始写，写到末尾就又回到开头循环写。</p>
<p>有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失。</p>
<p>详细的步骤：</p>
<ol>
<li><p><strong>连接、分析、优化、执行</strong></p>
<p>首先还是通过一个数据库连接发送到MySQL上，经过分析器、优化器等环节，生成执行计划，接着由执行器负责计划的执行。</p>
</li>
<li><p><strong>获取数据</strong></p>
<p>执行器先找数据，如果数据本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。</p>
</li>
<li><p><strong>执行操作</strong></p>
<p>执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据。</p>
</li>
<li><p><strong>更新redo log（第一阶段）</strong></p>
<p>这个redo log的更新是一个<strong>二阶段提交</strong>的过程，引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。</p>
</li>
<li><p><strong>生成bin log并存盘</strong></p>
<p>执行器生成这个操作的 binlog，并把 binlog 写入磁盘。</p>
</li>
<li><p><strong>更新redo log（第二阶段）</strong></p>
<p>执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。</p>
</li>
</ol>
<h4 id="a-为什么redo-log的更新需要两阶段提交？"><a href="#a-为什么redo-log的更新需要两阶段提交？" class="headerlink" title="a. 为什么redo log的更新需要两阶段提交？"></a>a. 为什么redo log的更新需要两阶段提交？</h4><p>如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致。</p>
<p>比如说先写bin log再写redo log，或者先写redo log再写bin log，都会有问题，都会导致通过bin log恢复和通过redo log恢复出来的数据不一致。</p>
<p>当你需要扩容的时候，也就是需要再多搭建一些备库来增加系统的读能力的时候，现在常见的做法也是用全量备份加上应用 binlog 来实现的，这个“不一致”就会导致你的线上出现主从数据库不一致的情况。</p>
<h4 id="b-redo-log和bin-log的区别："><a href="#b-redo-log和bin-log的区别：" class="headerlink" title="b. redo log和bin log的区别："></a>b. redo log和bin log的区别：</h4><ol>
<li>从作用的角度来考虑，redo log主要是用于</li>
<li>redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。</li>
<li>redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。</li>
<li>redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</li>
</ol>
<p><strong>事务</strong></p>
<p>对于事务而言，如果还没提交事务，MySQL就宕机了，此时Buffer Pool中的数据会全部丢失，写入Redo Log Buffer 中的Redo Log也会丢失，但是因为没有提交就宕机表示事务是执行失败了，他还没有更新磁盘，所以是不会有问题的</p>
<p>当提交事务的时候，会根据一定的策略将redo log buffer中的redo log内容刷入磁盘文件中。</p>
<p>这个策略有以下几种：</p>
<ol>
<li>提交事务的时候不会将redo log buffer中的数据刷到磁盘中的，此时可能提交事务了，但是mysql宕机，导致内存中的数据和redo log全部丢失。</li>
<li>提交事务的时候必须把redo log 从内存中刷入磁盘文件，换句话说，一旦事务提交成功，redolog就一定在磁盘文件里。此时就算buffer pool中更新过的数据没有刷到磁盘中，mysql也可以根据redo log 去恢复之前做过的修改</li>
<li>提交事务的时候，把redo log写入到磁盘文件对应的OS cache缓存中，而不是直接写入磁盘文件，可能1秒之后才会把OS cache中的数据写到磁盘文件中。这种情况下，可能宕机的时候redo log还在OS cache中没有刷到磁盘中，那么数据就会丢失。</li>
</ol>
<p>在提交事务的时候，同时也会写入binlog</p>
<p>对于binlog日志，有不同的刷盘策略，</p>
<ol>
<li>通过OS cache进行缓存，binlog先写入OS cache中，和redo log的刷新机制一样，如果在OS cache中就宕机，则其中的binlog就会丢失。</li>
<li>直接写入磁盘，这种情况下，提交事务之后，直接刷盘，即使机器宕机，也不会丢失binlog</li>
</ol>
<p>当把binlog写入磁盘文件之后，就会完成最终的事务提交，此时会把本次更新的binlog文件名称和这次更新的binlog日志在文件中的位置都写到redo log中，同时在redo log日志文件中写入一个commit标记。</p>
<p>完成了这些才算是真正完成了事务的提交。</p>
<h2 id="4-MySQL中的结构"><a href="#4-MySQL中的结构" class="headerlink" title="4. MySQL中的结构"></a>4. MySQL中的结构</h2><p>在执行更新数据的SQL语句的时候会用到buffer pool和redo log，还有一些相关的概念：</p>
<h3 id="4-1-缓冲池（Buffer-Pool）"><a href="#4-1-缓冲池（Buffer-Pool）" class="headerlink" title="4.1 缓冲池（Buffer Pool）"></a>4.1 缓冲池（Buffer Pool）</h3><p>缓冲池是Innodb中比较重要的组件，放在内存中，里面会缓存很多的数据，方便以后查询的时候，不必再去磁盘中查询了</p>
<h3 id="4-2-undo-Log"><a href="#4-2-undo-Log" class="headerlink" title="4.2 undo Log"></a>4.2 undo Log</h3><p>就是将更新前的值放进undo log文件中，可以使得更新的数据能够回滚</p>
<h3 id="4-3-redo-Log"><a href="#4-3-redo-Log" class="headerlink" title="4.3 redo Log"></a>4.3 redo Log</h3><p>防止在发生故障的时间点，尚有脏页未写入磁盘。在重启mysql服务的时候，根据redo log进行重做，从而达到事务的持久性这一特性。</p>
<p>redo log是一种偏向物理性质的重做日志，它里面记录的东西类似于：对某个数据页中的什么记录做了个什么修改</p>
<p>它是属于innodb存储引擎特有的一个东西</p>
<h3 id="4-4-bin-log"><a href="#4-4-bin-log" class="headerlink" title="4.4 bin log"></a>4.4 bin log</h3><p>用于复制，在主从复制中，从库利用主库上的binlog进行重播，实现主从同步。同时也可以用于数据库的基于时间点的还原。</p>
<p>binlog叫做归档日志，它里面存的是偏向于逻辑性的日志，例如：对那个表的id=几的一行数据做了更新操作，更新后的值是多少，并且binlog并不是innodb特有的，而是属于mysql的范畴</p>
<h1 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h1><h2 id="1-几种join"><a href="#1-几种join" class="headerlink" title="1. 几种join"></a>1. 几种join</h2><ol>
<li><p>left join</p>
<p>以表A为主，关联上表B的数据，最终的结果是：A表中的全部数据和B表中与A表重合的数据</p>
<img src="/2020/05/12/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93/image-20200611094609665.png" alt="left join" style="zoom: 50%;">

<pre><code class="mysql">SELECT &lt;select_list&gt;
FROM Table_A A
LEFT JOIN Table_B B
ON A.Key = B.Key</code></pre>
</li>
</ol>
<ol start="2">
<li><p>right join</p>
<p>以表B为主，关联上表A的数据，最终的结果是：B表中的全部数据和B表中与A表重合的数据</p>
<img src="/2020/05/12/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93/image-20200611094841686.png" alt="right join" style="zoom:50%;">

<pre><code class="mysql">SELECT &lt;select_list&gt;
FROM Table_A A
RIGHT JOIN Table_B B
ON A.Key = B.Key</code></pre>
</li>
</ol>
<ol start="3">
<li><p>inner join（join）</p>
<p>展示交集，没有关联的部分就不展示</p>
<img src="/2020/05/12/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93/image-20200611094543524.png" alt="inner join（join）" style="zoom: 50%;">

<pre><code class="mysql">SELECT &lt;select_list&gt; 
FROM Table_A A
INNER JOIN Table_B B
ON A.Key = B.Key</code></pre>
</li>
</ol>
<ol start="4">
<li><p>full outer join</p>
<p>求并集</p>
</li>
</ol>
   <img src="/2020/05/12/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93/image-20200611094857756.png" alt="full outer join" style="zoom:50%;">

<pre><code class="mysql">   SELECT &lt;select_list&gt;
   FROM Table_A A
   FULL OUTER JOIN Table_B B
   ON A.Key = B.Key</code></pre>
<ol start="5">
<li><p>left excluding join</p>
<p>相当于在left join的语句后面加一个where判断，将B为null的排除掉</p>
<img src="/2020/05/12/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93/image-20200611095036831.png" alt="left excluding join" style="zoom:50%;">

<pre><code class="mysql">SELECT &lt;select_list&gt; 
FROM Table_A A
LEFT JOIN Table_B B
ON A.Key = B.Key
WHERE B.Key IS NULL</code></pre>
</li>
</ol>
<ol start="6">
<li><p>right excluding join</p>
<img src="/2020/05/12/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93/image-20200611095044933.png" alt="right excluding join" style="zoom:50%;">

<pre><code class="mysql">SELECT &lt;select_list&gt;
FROM Table_A A
RIGHT JOIN Table_B B
ON A.Key = B.Key
WHERE A.Key IS NULL</code></pre>
</li>
</ol>
<ol start="7">
<li><p>outer excluding join</p>
<img src="/2020/05/12/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93/image-20200611095056551.png" alt="outer excluding join" style="zoom:50%;">

<pre><code class="mysql">SELECT &lt;select_list&gt;
FROM Table_A A
FULL OUTER JOIN Table_B B
ON A.Key = B.Key
WHERE A.Key IS NULL OR B.Key IS NULL</code></pre>
</li>
</ol>
<h1 id="数据库三范式"><a href="#数据库三范式" class="headerlink" title="数据库三范式"></a>数据库三范式</h1><ul>
<li><p>1NF：数据库表中的任何属性都是原子性的，不可再分（<strong>字段不可分</strong>）</p>
</li>
<li><p>2NF：非主属性要与数据表中的任意候选键有完全依赖关系（<strong>非主键字段完全依赖于主键</strong>）</p>
<blockquote>
<p>候选键指的是具有成为主键的资质，但是并不是主键的键</p>
</blockquote>
</li>
<li><p>3NF ：对于任何非主属性都要与主属性有直接关系，不存在传递依赖（非主键要和主键有直接关系，<strong>不能传递依赖</strong>）</p>
</li>
</ul>
<p><strong>反范式</strong>：通过增加冗余，重复数据来提高数据库的读性能</p>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>数据库的事务是指一组sql语句，在这组的sql操作中，要么全部执行成功，要么全部执行失败。</p>
<h2 id="1-事务的ACID特性"><a href="#1-事务的ACID特性" class="headerlink" title="1. 事务的ACID特性"></a>1. 事务的ACID特性</h2><ol>
<li><p><strong>原子性（Atomicity）</strong></p>
<p>事务被视为不可分割的最小单元，事务的所有操作要么全部成功提交，要么全部失败回滚，回滚可以通过回滚日志来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可</p>
<p>原子性基于日志的 <code>Redo/Undo</code> 机制实现</p>
</li>
<li><p><strong>一致性（Consistency）</strong></p>
<p>数据库在事务执行前后保持一致性状态，所有事务对一个数据的读取结果都是相同的</p>
</li>
<li><p><strong>隔离性（Isolation）</strong></p>
<p>一个事务所做的修改在最终提交之前对其他事务不可见</p>
</li>
<li><p><strong>持久性（Durability）</strong></p>
<p>一旦事务提交，其所做的修改会被永远保存在数据库中，即使系统发生崩溃，事务执行的结果也不会丢失，通过重做日志（RedoLog）来保证持久性</p>
</li>
</ol>
<h2 id="2-事务隔离级别与三大问题"><a href="#2-事务隔离级别与三大问题" class="headerlink" title="2. 事务隔离级别与三大问题"></a>2. 事务隔离级别与三大问题</h2><h3 id="2-1-三大问题"><a href="#2-1-三大问题" class="headerlink" title="2.1 三大问题"></a>2.1 三大问题</h3><ol>
<li><strong>脏读</strong>：事务A读取到了事务B未提交的更改，如果B回滚，则A读到的数据都是不合法的</li>
<li><strong>不可重复读</strong>：事务A在事务B提交之前读取到的值与事务B提交之后读取到的值是不一样的</li>
<li><strong>幻读</strong>：事务A读取某个范围的数据之后，事务B在该范围之内增加了新数据，A再次读取该范围的数据会读取到之前没有的数据</li>
</ol>
<p>不可重复读和幻读的区别在于，不可重复读是读到的数据被修改，幻读是读到了之前没有的数据，因此需要在区间上也加锁，即只能使用Next-Key Locks 将区间锁上，解决幻读，而只锁记录是无法解决的。</p>
<h3 id="2-2-四大隔离级别"><a href="#2-2-四大隔离级别" class="headerlink" title="2.2 四大隔离级别"></a>2.2 四大隔离级别</h3><ol>
<li><p><strong>——读未提交——</strong></p>
<p>​            脏读</p>
</li>
<li><p><strong>——读已提交——</strong></p>
<p>​      不可重复读</p>
</li>
<li><p><strong>——可重复读——</strong></p>
<p>​           幻读</p>
</li>
<li><p><strong>——串行化——</strong>：就是不允许多个事务并发执行，同一个时间只能有一个事务正在执行</p>
</li>
</ol>
<p>在MySQL中，默认的隔离级别是RR（可重复读），但是MySQL的RR隔离级别和SQL语言规定的RR级别是不一样的，它<strong>可以避免幻读</strong>。</p>
<p>也就是说，<strong>在MySQL里面执行事务，默认情况下是不会发生脏读、不可重复读、幻读的问题的，并且事务的执行是并行的，大家不会互相影响。</strong></p>
<h2 id="3-隔离级别的实现"><a href="#3-隔离级别的实现" class="headerlink" title="3. 隔离级别的实现"></a>3. 隔离级别的实现</h2><ul>
<li>Read uncommitted的实现：每次读时都读最新的那个版本，并发问题最严重</li>
<li>Read committed的实现：避免脏写，在每次读取数据时都生成一个readview，readview其中存有创建当前结构的事务ID，活跃事务ID，然后从记录开始读每个undo log，如果某个undo log刚好是事务的创建ID或不在readview的活跃事务列表中就可以读，这样就避免了脏读。</li>
<li>Repeatable read的实现：在事务第一次读的时候生成readview，然后读记录，这样就能保证事务中两次读取的结果一样。</li>
<li>Serializable的实现：依赖mysql的锁</li>
</ul>
<h2 id="4-事务的启动方式"><a href="#4-事务的启动方式" class="headerlink" title="4. 事务的启动方式"></a>4. 事务的启动方式</h2><ol>
<li>显式启动事务语句，begin或者start transaction,提交commit，回滚rollback；</li>
<li>set autocommit=0，该命令会<strong>把这个线程的自动提交关掉</strong>。这样<strong>只要执行一个select语句，事务就启动，并不会自动提交，直到主动执行commit或rollback或断开连接</strong>。</li>
</ol>
<h1 id="当前读与快照读"><a href="#当前读与快照读" class="headerlink" title="当前读与快照读"></a>当前读与快照读</h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h2><p>InnoDB存储引擎，为了提高并发，使用MVCC机制。在并发事务时，通过读取数据行的历史数据版本，来提高并发的一种机制。当我们查询数据库某个时间点的快照时，只能看到这个时间点之前事务提交更新的结果，不能看到时间点之后事务提交更新的结果。</p>
<p><strong>快照读</strong>：读取的时快照数据，不加锁的简单SELECT就是快照读</p>
<p><strong>当前读</strong>：读取的时最新的数据，不是历史版本。加锁的SELECT，或者对数据进行增删改时，就需要进行当前读</p>
<h2 id="2-RR当前读、快照读的幻读解决"><a href="#2-RR当前读、快照读的幻读解决" class="headerlink" title="2. RR当前读、快照读的幻读解决"></a>2. RR当前读、快照读的幻读解决</h2><p>innodb的默认事务隔离级别是RR（可重复读）。</p>
<ul>
<li>对于<strong>RR隔离级别的快照读</strong>版本，它的实现技术是mvcc + undo log。基于版本的控制协议。该技术不仅可以保证innodb的可重复读，而且可以防止幻读。（这也就是是此前以rr隔离级别实践时，不仅可以防止可重复读，也防止了幻读）但是它防止的是快照读，也就是读取的数据虽然是一致的，但是数据是历史数据。</li>
<li>对于<strong>RR隔离级别的当前读</strong>版本，它是通过 MVCC + Next-key Lock来实现的，innodb提供了一个间隙锁的技术，<strong>即next－key，也就是结合grap锁与行锁，</strong>达到最终目的。</li>
</ul>
<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><p>锁的粒度越小，并发度就越高，但是系统的开销就越大</p>
<h2 id="1-共享锁与排它锁"><a href="#1-共享锁与排它锁" class="headerlink" title="1. 共享锁与排它锁"></a>1. 共享锁与排它锁</h2><ul>
<li><strong>共享锁</strong>：称为S锁，对于锁定的资源，能够并行读，但是不能进行写操作；</li>
<li><strong>排它锁</strong>：称为X锁，假如当前写操作没有完成，那么它会阻断其它的写锁和读锁，即写加锁，其它读写都阻塞。</li>
</ul>
<h2 id="2-全局锁、表锁与行锁"><a href="#2-全局锁、表锁与行锁" class="headerlink" title="2. 全局锁、表锁与行锁"></a>2. 全局锁、表锁与行锁</h2><p>根据加锁的范围，分为三种不同的类型：</p>
<ul>
<li><p><strong>全局锁</strong></p>
<p>全局锁就是对整个数据库实例加锁</p>
<p>全局锁的典型使用场景是，做<strong>全库逻辑备份</strong>。也就是把整库每个表都 select 出来存成文本。</p>
</li>
<li><p><strong>行锁</strong></p>
<p>锁定当前数据行，事务A更新了一行，事务B也要更新这一行，则必须等待事务A进行commit或者rollback之后，事务B才可以执行。锁的粒度小，加锁慢，发生锁冲突的概率小，并发度高。</p>
<p>行锁也是MyISAM和InnoDB的区别之一，InnoDB支持行锁并且支持事务，myisam则不支持行锁</p>
</li>
<li><p><strong>表锁</strong></p>
<pre><code class="mysql">lock tables t1 read, t2 write;</code></pre>
<p>表锁则锁的粒度大，加锁快，开销小，但是锁冲突的概率大，并发度低。</p>
</li>
</ul>
<h2 id="3-意向锁"><a href="#3-意向锁" class="headerlink" title="3. 意向锁"></a>3. 意向锁</h2><p><strong>意向锁</strong>：给上一个级别的空间示意这里面是否加了锁</p>
<p>例如，给某一行的数据加上排它锁时，DB会给比行大一级的空间（如页 / 表）加上意向锁，告诉其他人这个页 / 表中已经有人上过排它锁了，不可以对整个表进行全局扫描。这样就避免了其他事务想给页 / 表加锁时去朱行扫描整个页 / 表。</p>
<h2 id="4-间隙锁-Gap-Lock、Next-Key-Lock"><a href="#4-间隙锁-Gap-Lock、Next-Key-Lock" class="headerlink" title="4. 间隙锁 (Gap Lock、Next-Key Lock)"></a>4. 间隙锁 (Gap Lock、Next-Key Lock)</h2><p>间隙锁则分为两种：<code>Gap Locks</code> 和 <code>Next-Key Locks</code>。</p>
<ul>
<li>Gap Locks会锁住两个索引之间的区间，比如 <code>select * from User where id&gt;3 and id&lt;5 for update</code>，就会在区间（3，5）之间加上Gap Locks。</li>
<li>Next-Key Locks是Gap Locks+Record Locks形成闭区间锁 <code>select * from User where id&gt;=3 and id=&lt;5 for update</code>，就会在区间[3,5]之间加上Next-Key Locks。</li>
</ul>
<h2 id="5-何时加锁"><a href="#5-何时加锁" class="headerlink" title="5. 何时加锁"></a>5. 何时加锁</h2><p>在数据库的增、删、改、查中，只有增、删、改才会加上排它锁，而只是查询并不会加锁，只能通过在select语句后显式加lock in share mode或者for update来加共享锁或者排它锁。</p>
<h2 id="6-死锁"><a href="#6-死锁" class="headerlink" title="6. 死锁"></a>6. 死锁</h2><p>死锁一般是事务相互持有对方的资源，并且等待对方资源，最后形成环路造成的。</p>
<p>比如下图中的A和B两个事务，A事务先修改id=1的数据，然后修改id=2的数据，B事务先修改id=2的数据，然后修改id=1的数据，这样A事务对id=1的数据加了锁，B事务对id=2的数据加了锁，这样A持有B需要的锁，B持有A需要的锁，就形成了死锁。</p>
<img src="/2020/05/12/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93/image-20200612225926121.png" alt="两个事务的执行流程" style="zoom:80%;">

<h3 id="6-1-死锁的解决"><a href="#6-1-死锁的解决" class="headerlink" title="6.1 死锁的解决"></a>6.1 死锁的解决</h3><ol>
<li>直接等待，并且设置一个超时时间，但是如果设置的超时时间太短会导致误判，如果时间太长也不好。</li>
<li>进行死锁检测，如果发现死锁，就回滚其中一个事务，可以让另一个事务继续执行下去，但是这种方式会造成性能的额外开销。</li>
</ol>
<p>如果事务中需要锁多个行，要把<strong>最可能造成锁冲突、最可能影响并发度的锁的申请时机尽量往后放</strong>。</p>
<p>因此，就简要来说，减少死锁的主要方向，就是控制访问相同资源的并发事务量，尽量避免死锁，而不是去解决死锁。</p>
<h1 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h1><h2 id="0-乐观锁与悲观锁"><a href="#0-乐观锁与悲观锁" class="headerlink" title="0. 乐观锁与悲观锁"></a>0. 乐观锁与悲观锁</h2><ul>
<li><p><strong>悲观锁</strong>：指对数据被外界修改这一事件保持保守态度，认为总会有外界来修改数据。在整个数据处理过程中，将数据处于锁定状态，悲观锁的实现往往依靠数据库提供的锁机制</p>
</li>
<li><p><strong>乐观锁</strong>：认为数据一般情况下不会产生冲突，因此只会在数据进行提交更新的时候，才会对数据是否冲突进行检测，如果发现了冲突就返回错误信息，让用户决定如何去做</p>
</li>
</ul>
<p>最早的数据库系统，只有读读之间可以并发，读写，写读，写写都要阻塞。引入多版本之后，只有写写之间相互阻塞，其他三种操作都可以并行，这样大幅度提高了InnoDB的并发度。</p>
<p>MVCC是为了实现读-写冲突的不加锁，这里的读就是快照读，是一种乐观锁。</p>
<p>也就是说，如果在有人更新数据的时候，你要去读取这个数据，是没问题的，完全根据UndoLog，从版本链中找到一条可以读的数据，从而不需要加锁，避免频繁的加锁互斥。</p>
<h2 id="1-UndoLog回滚日志"><a href="#1-UndoLog回滚日志" class="headerlink" title="1. UndoLog回滚日志"></a>1. UndoLog回滚日志</h2><p>MVCC使用到的快照存储在UndoLog中，该日志通过回滚指针把一个数据行（Record）的所有快照都连接起来。</p>
<p>UndoLog存储在每个数据行尾部的隐藏列中，InnoDB在每行后面有隐藏列，其中<strong>和MVCC有关的两个列</strong>是：</p>
<ol start="2">
<li><strong>trx_id（最近一次更新这条数据的事务ID）</strong>：就是最近一次更新这条数据的事务的ID</li>
<li><strong>rollback_ptr（回滚指针）</strong>：指向UndoLog信息，通过一个回滚指针把一个数据行的所有快照（历史版本）全部连接起来</li>
</ol>
<p>下面是关于undolog的更新方式</p>
<ul>
<li>插入：假设有一个事务A，它的ID是50，插入了一条数据，将这条数据的trx_id设置为当前的ID，并且由于是新插入的数据，因此rollback指针会指向一个空的undo log</li>
<li>更新：假设有另一个事务B，它的ID是51，来修改这个值，此时更新之前会生成一个undolog来记录之前的值，然后把数据更新，并且更改它的两个隐藏字段，让回滚指针指向历史版本的undolog</li>
</ul>
<p>也就是说，<strong>每一条数据都会通过它尾部隐藏的回滚指针字段将它的历史版本的undolog给串联起来</strong>。</p>
<h2 id="2-ReadView"><a href="#2-ReadView" class="headerlink" title="2. ReadView"></a>2. ReadView</h2><p>事务在<strong>第一次查询的时候，会创建一个ReadView</strong>，在这个ReadView中统计四个信息：创建这个ReadView的事务ID，活跃的事务ID，还有活跃事务中最大最小的事务ID</p>
<p>ReadView中维护了一批事务ID，包含四个部分：</p>
<ol>
<li>正在活跃的事务ID集合</li>
<li>活跃的事务中最大的事务ID</li>
<li>活跃的事务中最小的事务ID</li>
<li>创建这个ReadView的事务ID（也就是本事务ID）</li>
</ol>
<p>ReadView需要和undolog多版本链来配合使用，通过对比ReadView中的活跃事务ID与undolog中的trx_id的大小来确定记录是否可以被访问到。分为以下三种情况：</p>
<ol>
<li><p><strong>本行数据的trx_id(最后一次被修改的事务ID) &lt; 活跃的最小事务ID</strong></p>
<p>表示本行记录上一次被修改的时候当前活跃的这些事务还没开启呢，并且当前事务是比最小活跃事务的ID还要大的，也就是比，因此本行记录对于当前事务是可见的</p>
</li>
<li><p><strong>本行数据的trx_id(最后一次被修改的事务ID) &gt; 活跃的最大事务ID</strong></p>
<p>表示本行记录上一次被修改的时候，当前活跃的这些事务都已经开启了，因此为了保证RR，该行记录对本事务不可见，他需要去翻UndoLog，直到找到一个可见的版本</p>
</li>
<li><p><strong>本行数据的trx_id(最后一次被修改的事务ID) 介于最大与最小事务ID之间</strong></p>
<p>查找事务ID是否在活跃事务集合中，如果在，则表示本事务还在活跃，不可见，否则表示事务已经完成提交，可见</p>
</li>
</ol>
<h2 id="3-ReadView实现RC与RR"><a href="#3-ReadView实现RC与RR" class="headerlink" title="3. ReadView实现RC与RR"></a>3. ReadView实现RC与RR</h2><h3 id="3-1-RC"><a href="#3-1-RC" class="headerlink" title="3.1 RC"></a>3.1 RC</h3><p>RC隔离级别指的是，在事务的运行期间，只要别的事务修改数据并且提交了，就可以读取到人家修改的事务的。</p>
<p>实现RC就是通过ReadView来做的，在每次进行查询的时候都生成一个新的ReadView。</p>
<p>来分析一下流程吧，事务A在生成ReadView之后，去查询某个数据，这时候，如果这个数据恰好被另一个事务B修改过，并且这个事务B还没有结束，那么这个事务B就会存在于事务A的ReadView的活跃事务集合中，此时，即使事务A读取到了被事务B修改过的数据，也会因为这个数据的trx_id在ReadView中，从而会通过回滚指针查询历史版本的undolog。如果事务B执行完成，此时事务A又进行了一次查询，这时候重新生成了一个ReadView，只不过此时由于事务B已经完成，就不会出现在事务A的ReadView中了，这个数据对于事务A就是可见的，也就实现了读已提交</p>
<h3 id="3-2-RR"><a href="#3-2-RR" class="headerlink" title="3.2 RR"></a>3.2 RR</h3><p>RR隔离级别是，对于同一个事务，它去读取某个数据的时候，不会因为另一个事务的提交导致两次读取的结果不同。</p>
<p>RR也是通过ReadView来实现的，事务开启的时候创建一个ReadView，此后本事务的所有查询都会基于这个ReadView进行。</p>
<p>分析过程和上面其实差不太多，唯一一点不同的是，事务B在提交之后，虽然已经不活跃了，但是在事务A的ReadView中，依然是存在的，它始终被事务A当做是正在运行的状态，就不会去读取该事务修改的所有数据了。</p>
<p>还有一个需要关注的点是，MySQL的RR隔离级别是可以避免幻读的，它避免幻读分两种不同的场景，一种是当前读一种是快照读，对于快照读，可以使用MVCC来解决，而要避免当前读场景下的幻读，则需要通过Next-Key Lock，这个Lock是结合了行锁和间隙锁，可以把索引的间隙也锁起来，避免在区间内插入数据。这样就是用到了锁。</p>
<h2 id="4-MVCC的原理"><a href="#4-MVCC的原理" class="headerlink" title="4. MVCC的原理"></a>4. MVCC的原理</h2><p>在内部实现中，MVCC是通过 UndoLog + ReadView 进行数据读取的。</p>
<p><strong>具体的流程</strong>：</p>
<ol>
<li>先获取事务自己的ID（事务版本号）</li>
<li>获取ReadView</li>
<li>查询得到数据，然后与ReadView中的事务版本号进行对比</li>
<li>如果不符规则，则从UndoLog（回滚日志）中查询历史快照来找到符合规则的数据</li>
<li>返回符合规则的数据</li>
</ol>
<h1 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h1><h2 id="1-行锁的三种实现方式"><a href="#1-行锁的三种实现方式" class="headerlink" title="1. 行锁的三种实现方式"></a>1. 行锁的三种实现方式</h2><ol>
<li><p><strong>Record Locks（记录锁）</strong></p>
<p>锁定一个记录上的索引，而不是锁定记录本身，如果没有创建索引，就会自动在主键上创建聚集索引，因此它依然是可用的</p>
</li>
<li><p><strong>Gap Locks（间隙锁）</strong></p>
<p>锁定索引之间的间隔，不包含索引本身</p>
</li>
<li><p><strong>Next-Key Locks</strong></p>
<p>是上面两种锁的结合，既锁定索引本身，也锁定记录之间的间隔</p>
</li>
</ol>
<h2 id="2-对比InnoDB和MyISAM"><a href="#2-对比InnoDB和MyISAM" class="headerlink" title="2. 对比InnoDB和MyISAM"></a>2. 对比InnoDB和MyISAM</h2><p><strong>相同之处</strong>：</p>
<p>首先他们的底层数据结构都是B+树，在非叶子结点中不存储数据，所有的数据都存储在叶子节点上。</p>
<p><strong>不同之处</strong>：</p>
<p>其不同之处在于对事务的支持、外键约束的支持、以及对高并发的支持，此外，其存储数据的方式也是不一样的</p>
<ol>
<li><p>myisam</p>
<p>不支持事务，不支持外键约束。</p>
<p>在myisam存储引擎的索引中，<strong>每个叶子节点的data存放的是数据行的物理地址</strong>。进行数据查询时，先是索引文件里搜索，得到数据在文件里的定位，然后再去文件的指定位置获取到数据。</p>
<p>这样在内存里可以缓存更多的索引，对查询的性能会更好，适用于那种少量的插入，大量查询的场景。比如一次性批量导入，接下来一天之内就是纯查询的那种应用场景。</p>
</li>
<li><p>innodb</p>
<p>主要特点就是<strong>支持事务</strong>，支持外键约束，而且还可以进行分库分表、读写分离、主备切换</p>
<p><strong>强制要求有主键，其默认会根据主键创建一个索引，叫做聚集索引，同时它的数据文件本身也是通过这个聚集索引（主键）建立的</strong>。而myisam则不需要强制有主键</p>
<p>另外一点，innodb存储引擎下，如果对某个非主键的字段创建索引，那么该索引的<strong>叶子节点中存储的就是主键的值</strong>，然后再用主键的值到聚簇索引里查找到数据，即所谓的<strong>回表</strong>。</p>
<p>因此在一般innodb表里，一般都是用自增值作为主键的，因为这样可以使得更新聚簇索引时直接往里面加记录，如果用那种不是单调递增的主键值，在添加数据更新聚集索引时可能会导致b+树分裂后重新组织，会浪费时间。</p>
</li>
</ol>
<h1 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h1><p>数据库的索引是存储在磁盘上的，当数据量大时，就不能把整个索引全部加到内存中，只能注意加载每个磁盘页，因此要减少IO的次数，对于树来说，IO次数就是树的高度，而矮胖就是b树的特征之一，它的每个节点最多包含m个孩子，m为b树的阶，m的大小取决于磁盘页的大小</p>
<h2 id="1-B树"><a href="#1-B树" class="headerlink" title="1. B树"></a>1. B树</h2><p>树中的每个节点有n个key和n+1个指针构成，key左边的指针指向的节点中的key都小于当前的key，key右边的指针指向的节点中的key都大于当前的key</p>
<p>另外一点是，B树的data是存在树的节点中的，因此搜索可能在非叶子结点结束。要在B树中查找某个数据，先与根节点的关键字比较，选定下一步走哪一个子树，直到找到结果。</p>
<h2 id="2-B-树"><a href="#2-B-树" class="headerlink" title="2. B+树"></a>2. B+树</h2><p>B+树与B树是比较类似的，只不过有一点不同，就是非叶子节点不存储data，只用作索引，所有的data都在叶子节点，并且叶子节点构成一个链表，按照key的大小进行顺序连接。</p>
<p><strong>对于Innodb而言，叶子节点中存储的内容是聚集索引，也可以理解为数据行的物理地址</strong></p>
<p>它的数据文件是单独放一个文件的。</p>
<h2 id="3-对比B-树和B树"><a href="#3-对比B-树和B树" class="headerlink" title="3. 对比B+树和B树"></a>3. 对比B+树和B树</h2><ol>
<li><strong>B+树的磁盘读写代价更低</strong>：B+树内部节点不是数据节点，也没有指向关键字的具体指针，因此在磁盘中存储时，一个盘块就能存储更多的内部节点，使得B+树从磁盘中读写中间节点的IO读写次数更少</li>
<li><strong>B+树的查询比B树稳定</strong>：因为B树可能在查询的过程中就结束，而B+树一定会查询到叶子节点，使得每次查询的路径长度相同，效率相当。</li>
<li><strong>B+树的查询效率高</strong>：所有的数据都出现在叶子节点上，并且通过链表连接，因此，对于范围查询会更高效，而B树需要中序遍历才可以完成范围的查询</li>
</ol>
<h2 id="4-对比B-树和红黑树-平衡树"><a href="#4-对比B-树和红黑树-平衡树" class="headerlink" title="4. 对比B+树和红黑树/平衡树"></a>4. 对比B+树和红黑树/平衡树</h2><p>红黑树或者其他的平衡树也可以用来实现索引，但是文件系统和数据库中普遍使用B+树，原因是：</p>
<ol>
<li><strong>更少的查找次数</strong>：平衡树每个节点的出度为2，而B+树的出度可以很大，会使得B+树普遍比较矮胖，可以降低树的深度，也就是降低了查找的次数</li>
<li><strong>利用磁盘的预读特性</strong>：每次从磁盘中读取的时候，会读取固定大小的块，因此可能使得一次IO操作就完全载入一个节点，甚至可以预先载入其相邻的节点</li>
</ol>
<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>数据库的索引类似于目录，可以用于快速进行特定值的定位和查找，是一种数据结构，以某种方式指向数据，可以进行高效查找</p>
<h2 id="1-索引的优劣势"><a href="#1-索引的优劣势" class="headerlink" title="1. 索引的优劣势"></a>1. 索引的优劣势</h2><p><strong>优势</strong>：</p>
<ul>
<li>提高数据的检索效率，降低数据库的IO成本</li>
<li>通过索引对数据排序，降低数据的排序成本，降低CPU的消耗</li>
</ul>
<p><strong>劣势</strong>：</p>
<ul>
<li>索引也是一张表，需要占用空间来保存主键与索引字段</li>
<li>虽然提高了查询效率，但是降低了更新速度，因为更新表的同时也需要更新索引</li>
</ul>
<p><strong>不适用索引的场景</strong>：</p>
<ul>
<li>数据的行数较少</li>
<li>数据的重复度很高（如男女性别）</li>
</ul>
<h2 id="2-索引的分类"><a href="#2-索引的分类" class="headerlink" title="2. 索引的分类"></a>2. 索引的分类</h2><ol>
<li><p>根据物理实现</p>
<ul>
<li><strong>聚集索引</strong>：每行数据是存在InnoDB聚集索引的叶子节点上的，因此InnoDB必须要有且只有一个聚集索引。数据的物理存储顺序与聚集索引的顺序相同</li>
<li><strong>非聚集索引</strong>：索引项顺序存储，但是索引项对应的内容是随机存储的</li>
</ul>
<p><strong>聚集索引一般是主键索引</strong>。可以将聚集索引比作字典中的按拼音查字，非聚集索引比作字典中的按偏旁查字，字在字典中的顺序和拼音的顺序一致，但是和偏旁没关系。</p>
</li>
<li><p>根据字段个数</p>
<ul>
<li><strong>单值索引</strong>：索引列为1列</li>
<li><strong>联合索引</strong>：索引值为多个列组合在一起创建的列，一般来说不是对一个一个的字段进行索引的，而是针对多个字段创建一个联合索引，<strong>联合索引在使用的时候需要遵循最左前缀原则</strong>。</li>
</ul>
</li>
<li><p>根据形式</p>
<ul>
<li><strong>普通索引</strong>：允许索引列中的值重复</li>
<li><strong>唯一索引</strong>：（满足UNIQUE）索引列的值必须唯一，允许有空值</li>
<li><strong>主键索引</strong>：（满足UNIQUE + NOT NULL）索引值必须唯一，并且不能为空</li>
<li><strong>全文索引</strong>：将存储在整个数据库中的任意信息查询出来</li>
</ul>
</li>
<li><p>根据稀疏程度</p>
<ul>
<li><strong>稀疏索引</strong>：对于排好序的记录，只针对某一些记录创建索引</li>
<li><strong>稠密索引</strong>：每一条记录都创建一个索引</li>
</ul>
</li>
</ol>
<h3 id="2-1-hash索引"><a href="#2-1-hash索引" class="headerlink" title="2.1 hash索引"></a>2.1 hash索引</h3><p>B+树对比hash索引</p>
<ul>
<li>哈希索引对于确定值的查询效率比B+树要高</li>
<li>哈希索引不能进行范围查询，因为哈希索引指向的数据是无序的</li>
<li>哈希索引无法进行模糊查询</li>
</ul>
<h3 id="2-2-聚集索引与普通索引"><a href="#2-2-聚集索引与普通索引" class="headerlink" title="2.2 聚集索引与普通索引"></a>2.2 聚集索引与普通索引</h3><p>每一个索引在 InnoDB 里面对应一棵 B+ 树。</p>
<p>假设，我们有一个主键列为 ID 的表，表中有字段 k，并且在 k 上有索引。这个表的建表语句是：</p>
<pre><code class="mysql">create table T(
    id int primary key, 
    k int not null, 
    name varchar(16),
    index (k)
)engine=InnoDB;</code></pre>
<p>索引类型分为<strong>主键索引</strong>和<strong>非主键索引</strong>。</p>
<ul>
<li><p>主键索引的叶子节点存的是整行数据。在 InnoDB 里，主键索引也被称为聚簇索引</p>
</li>
<li><p>非主键索引的叶子节点内容是主键的值。在 InnoDB 里，非主键索引也被称为二级索引</p>
<img src="/2020/05/12/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93/image-20200611223118674.png" alt="非主键索引（普通索引）" style="zoom:80%;">

</li>
</ul>
<p>如果使用主键查询方式，则只需要搜索 ID 这棵 B+ 树，如果是普通索引查询方式，则需要先搜索这棵普通索引树，得到 ID 的值为 500，再到 ID 索引树搜索一次。这个过程称为<strong>回表</strong>。也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询。</p>
<h3 id="2-3-覆盖索引"><a href="#2-3-覆盖索引" class="headerlink" title="2.3 覆盖索引"></a>2.3 覆盖索引</h3><p>如果一个<strong>索引覆盖（包含）了所有需要查询的字段的值，这个索引就是覆盖索引</strong>。因为索引中已经包含了要查询的字段的值，因此查询的时候直接返回索引中的字段值就可以了，不需要再到表中查询，避免了回表，也就提高了查询的效率。</p>
<p>实现覆盖索引的方式可分为两种：</p>
<ol>
<li><p><strong>减少查询字段，只查询索引有的字段</strong></p>
<p>例如我们上面提到的使用limit查询，我们只查了id字段，这样几百万条数据就不会<strong>回表查询</strong>，外层查询时只有50条数据去聚集索引里进行了查询。又如上面的user表 优化sql为不查询name字段。</p>
</li>
<li><p><strong>修改表创建的索引，增加需要查询的字段</strong></p>
<p>如上面user表，把name也加到索引中，设置（name，code）两个字段的联合索引 。</p>
</li>
</ol>
<p><strong>覆盖索引的定义与注意事项</strong></p>
<p>要注意的是，不是所有类型的索引都可以成为覆盖索引的。因为覆盖索引必须要存储索引的列值，而哈希索引、空间索引和全文索引等都不存储索引列值，索引MySQL只能使用B-Tree索引做覆盖索引。</p>
<p>另外，当发起一个被索引覆盖的查询（索引覆盖查询）时，在explain（执行计划）的Extra列可以看到【Using Index】的信息。</p>
<h3 id="2-4-唯一索引和普通索引"><a href="#2-4-唯一索引和普通索引" class="headerlink" title="2.4 唯一索引和普通索引"></a>2.4 唯一索引和普通索引</h3><ol>
<li><p><strong>查询过程</strong></p>
<p>唯一索引和普通索引二者之间的差距就在于，唯一索引是唯一的，在数据库中只存在一条这样的记录，因此，通过唯一索引查到结果之后会立即将结果返回，而通过普通索引查到第一个结果之后，还会继续往后查询，直到查询到所有的结果为止。</p>
<p>但是这二者之间的查询效率的差异可以忽略不计，因为InnoDB是按照数据页为单位进行读写的，一个数据页中可能就有上千个key，因此二者之间的效率差异较小</p>
</li>
<li><p><strong>更新过程</strong></p>
<p>相关的一个概念是change buffer</p>
<blockquote>
<p><strong>change buffer</strong>：当需要更新一个数据页时：</p>
<ol>
<li>如果数据页在内存中就直接更新</li>
<li>如果数据页还没有在内存中的话，在不影响数据一致性的前提下，InooDB会将这些更新操作缓存在change buffer中，这样就不需要从磁盘中读入这个数据页了。</li>
</ol>
<p>在下次查询需要访问这个数据页的时候，<strong>将数据页读入内存，然后执行change buffer中与这个页有关的操作</strong>，通过这种方式就能保证这个数据逻辑的正确性。</p>
<p>将change buffer中的操作应用到原数据页，得到最新结果的过程称为merge。除了访问这个数据页会触发merge外，系统有后台线程会定期merge。在数据库正常关闭（shutdown）的过程中，也会执行merge操作。</p>
</blockquote>
<p>将更新操作先记录在change buffer，减少读磁盘，语句的执行速度会得到明显的提升。而且，数据读入内存是需要占用buffer pool的，所以这种方式还能够避免占用内存，提高内存利用率</p>
<img src="/2020/05/12/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93/image-20200611120429357.png" alt="有change buffer的更新操作" style="zoom:80%;">

<p>唯一索引的更新就不能使用change buffer，因为对于唯一索引来说，<strong>所有的更新操作都要先判断这个操作是否违反唯一性约束</strong>。而<strong>必须要将数据页读入内存才能判断</strong>。如果都已经读入到内存了，那直接更新内存会更快，就没必要使用 change buffer 了。</p>
<p>只有普通索引可以使用change buffer。</p>
<p><strong>change buffer用的是buffer pool里的内存</strong>，因此不能无限增大，change buffer的大小，可以通过参数innodb_change_buffer_max_size来动态设置，这个参数设置为50的时候，表示change buffer的大小最多只能占用buffer pool的50%。</p>
<p>将数据从磁盘读入内存涉及随机IO的访问，是数据库里面成本最高的操作之一，change buffer因为减少了随机磁盘访问，所以对更新性能的提升是会很明显的。</p>
</li>
</ol>
<p><strong>change buffer 的适用场景</strong></p>
<ul>
<li>对于<strong>写多读少</strong>的业务来说，页面在写完以后马上被访问到的概率比较小，此时 change buffer 的使用效果最好。这种业务模型常见的就是账单类、日志类的系统。</li>
<li>反过来，假设一个业务的更新模式是写入之后马上会做查询，那么即使满足了条件，将更新先记录在 change buffer，但之后由于马上要访问这个数据页，会立即触发 merge 过程。这样随机访问 IO 的次数不会减少，反而增加了 change buffer 的维护代价。所以，对于这种业务模式来说，change buffer 反而起到了副作用。</li>
</ul>
<h3 id="2-5-前缀索引"><a href="#2-5-前缀索引" class="headerlink" title="2.5 前缀索引"></a>2.5 前缀索引</h3><p><strong>很长的字段，想做索引我们怎么去优化他呢？</strong></p>
<p>就是使用前缀索引，如果前缀区分度不大，可以做一个哈希，或者截取区分度较大的一部分子串作为索引</p>
<h2 id="3-最左前缀原则"><a href="#3-最左前缀原则" class="headerlink" title="3. 最左前缀原则"></a>3. 最左前缀原则</h2><p>对于一个联合索引，索引项是按照索引定义里面出现的字段顺序排序的。</p>
<p>因为可以支持最左前缀，所以<strong>当已经有了 (a,b) 这个联合索引后，一般就不需要单独在 a 上建立索引了</strong>。如果既有联合查询，又有基于 a、b 各自的查询呢？查询条件里面只有 b 的语句，是无法使用 (a,b) 这个联合索引的，这时候你不得不维护另外一个索引，也就是说你需要同时维护 (a,b)、(b) 这两个索引。</p>
<img src="/2020/05/12/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93/image-20200611230109068.png" alt="最左前缀原则" style="zoom:80%;">

<p>当你的逻辑需求是<strong>查到所有名字是“张三”的人</strong>时，可以快速定位到 ID4，然后向后遍历得到所有需要的结果。</p>
<p>如果你要查的是<strong>所有名字第一个字是“张”的人</strong>，你的 SQL 语句的条件是”where name like ‘张 %’”。这时，你也能够用上这个索引，查找到第一个符合条件的记录是 ID3，然后向后遍历，直到不满足条件为止。</p>
<p>这个最左前缀可以是联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符。</p>
<p>因此需要考虑的是：<strong>在建立联合索引的时候，如何安排索引内的字段顺序</strong>？</p>
<ol>
<li>如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。</li>
<li>空间原则，字段比较大的索引往往放在前面，避免建立冗余索引的时候占用过多的空间</li>
</ol>
<p>创建索引的时候一般都不是只对单个属性创建索引的，一般会使用联合索引，MySQL查询进行索引匹配时，会从左往右进行匹配，直到遇到范围查询就停下来，范围查询后面的键是用不到索引的。例如对于一个联合索引 <code>(a, b, c, d)</code>，某个查询为 <code>a = 1, b = 1, c &gt; 1, d = 1</code>，则a，b，c都可以走索引，但是d不能走索引，但是如果建立的索引是 <code>(a, b, d, c)</code>，则a，b，c，d都可以走索引。=的查询之间可以乱序，MySQL的查询优化器可以将索引优化成可以识别的形式。</p>
<p>注意，<strong>最左前缀原则是针对索引而言的</strong>，同样的字段，用不同的顺序创建索引，会导致不同的效率，而对于查询，则可以通过查询优化器将其优化为最佳的状态。</p>
<h2 id="4-索引下推"><a href="#4-索引下推" class="headerlink" title="4. 索引下推"></a>4. 索引下推</h2><p>在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。比如索引是name和age，有一个搜索是找name为某个值，age为某个值，ismale为某个值的数据，要走这个索引，如果没有下推优化，则会先根据name回一次表，然后根据age回一次表，如果有了索引下推优化，会在回表之前先判断一下索引中的另一个字段age是否满足要求，如果满足的话才进行回表，否则不回表，这样就减少了回表的次数。</p>
<p>对于下面这条SQL语句</p>
<pre><code class="mysql">select * from tuser where name like &#39;张%&#39; and age=10 and ismale=1;</code></pre>
<p>如果没有索引下推优化，则过程如下：</p>
<img src="/2020/05/12/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93/image-20200611231536746.png" alt="索引下推（未优化）" style="zoom:80%;">

<p>如果有索引下推，则过程如下：</p>
<img src="/2020/05/12/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93/image-20200611231555371.png" alt="索引下推（已优化）" style="zoom:80%;">

<h1 id="MySQL优化"><a href="#MySQL优化" class="headerlink" title="MySQL优化"></a>MySQL优化</h1><h2 id="1-总体思路"><a href="#1-总体思路" class="headerlink" title="1. 总体思路"></a>1. 总体思路</h2><p>数据库的结构图：</p>
<p><img src="/2020/05/12/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93/image-20200611105026003.png" alt="查询流程"></p>
<p>客户端通过连接器进行查询，先到缓存中查找是否存在结果，如果存在则直接返回查询结果，如果不存在，则进行数据库的查询操作，查询操作主要分为4步：分析器、优化器、执行器、引擎。</p>
<p>所谓的优化就是在<strong>执行器</strong>之前的分析器、优化器部分进行优化的。一般在开发涉及SQL的业务都会去本地环境跑一遍SQL，用explain去看一下执行计划，看看分析的结果是否符合自己的预期，用没用到相关的索引，然后再去线上环境跑一下看看执行时间（这里只有查询语句，修改语句也无法在线上执行）。</p>
<p>在本地跑的时候需要注意把缓存关掉，不然跑出来的时间都很短，测不出来效果</p>
<h2 id="2-explain"><a href="#2-explain" class="headerlink" title="2. explain"></a>2. explain</h2><ul>
<li>table：哪个表</li>
<li>type：这个很重要，是说类型，all（全表扫描），const（读常量，最多一条记录匹配），eq_ref（走主键，一般就最多一条记录匹配），index（扫描全部索引），range（扫描部分索引）</li>
<li>possible_keys：显示可能使用的索引</li>
<li>key：实际使用的索引，索引<strong>也不一定就是走最优的，是可能走错的</strong>。可以使用 force index 强制走正确的索引，或者优化SQL，最后实在不行，可以新建索引，或者删掉错误的索引。</li>
<li>key_len：使用索引的长度</li>
<li>ref：联合索引的哪一列被用了</li>
<li>rows：一共扫描和返回了多少行，这个<strong>行数只是一个接近的数字，不是完全正确的</strong></li>
<li>extra：using filesort（需要额外进行排序），using temporary（mysql构建了临时表，比如排序的时候），using where（就是对索引扫出来的数据再次根据where来过滤出了结果）</li>
</ul>
<h2 id="1-索引优化"><a href="#1-索引优化" class="headerlink" title="1. 索引优化"></a>1. 索引优化</h2><ol>
<li><p>建立聚集索引：数据库的物理存储顺序是按照聚集索引顺序排列的，通过聚集索引的B+树，可以快速查找到任何一行的全部信息</p>
</li>
<li><p>长查询的数据建立索引或者组合索引</p>
</li>
<li><p>最左匹配原则：建立组合索引优化查询时，要考虑最左匹配原则，不然创建的索引就没有意义</p>
</li>
<li><p>较长的数据列建立前缀索引</p>
<blockquote>
<p>当索引是很长的字符序列时，这个索引将会很占内存，而且会很慢，这时候就会用到前缀索引了。所谓的前缀索引就是去索引的前面几个字母作为索引，但是要降低索引的重复率，索引我们还必须要判断前缀索引的重复率。</p>
</blockquote>
</li>
<li><p>不要建立无意义的索引：对于查询次数很少的语句中的字段索引，或者大字段的索引</p>
</li>
</ol>
<h2 id="2-查询优化"><a href="#2-查询优化" class="headerlink" title="2. 查询优化"></a>2. 查询优化</h2><ol>
<li><p><strong>使用Explain分析执行计划</strong></p>
<p>Explain用来分析SELECT查询语句，<strong>一般其实就是看SQL有没有走索引，走了哪些索引，扫描了多少行，有没有排序等等</strong>，</p>
</li>
<li><p><strong>优化数据访问</strong></p>
<ul>
<li><p>减少请求的数据量</p>
<p>只返回必要的列，最好不要使用select *</p>
<p>只返回必要的行，使用LIMIT语句来限制返回的数据</p>
<p>缓存重复查询的数据：使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升会非常明显</p>
</li>
<li><p>减少服务器端扫描的行数</p>
<p>使用索引来覆盖查询</p>
</li>
</ul>
</li>
<li><p><strong>重构查询方式</strong></p>
<p>一个大查询如果一次性执行的话，可能会锁住很多的数据，这样就会阻塞住很多小的但是重要的查询，因此可以将一个大的查询分解成对每一个表进行一次单表查询，然后在应用程序中进行关联，这样做的好处是：</p>
<p>让缓存更高效，对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用，而分解后的多个查询，即使其中一个表发生变化，对其他的查询缓存依然可以可以使用。分解成多个单表查询，这些单表查询的缓存可能会被其他的查询使用到，就可以减少冗余记录的查询</p>
</li>
</ol>
<h2 id="3-优化例子1"><a href="#3-优化例子1" class="headerlink" title="3. 优化例子1"></a>3. 优化例子1</h2><p>数据库使用的MySQL，有一个日志表，需要进行分页查询，于是很容易就想到了limit [offset偏移量] [count数量]这个查询方式,当我们偏移量比较小时,似乎是没什么问题</p>
<pre><code class="mysql">SELECT    * FROM    t_log WHERE    type = 1 LIMIT 5, 50
查询时间:0.45s</code></pre>
<p>但是随着offset的增加,就出现了查询时间越来越长，但是每次查出的数据都只有50条，这就让我特别不理解</p>
<pre><code class="mysql">SELECT    * FROM    t_log WHERE    type = 1 LIMIT 500000, 50
查询时间:57.252s
SELECT    * FROM    t_log WHERE    type = 1 LIMIT 1000000, 50
查询时间:89.15s</code></pre>
<p>查阅资料发现“limit”的工作方式是：</p>
<ol>
<li>先查询offset+count条数据；</li>
<li>再抛弃前offset条数据</li>
</ol>
<p>但是全字段查询肯定会有回表查询操作，这就导致了进行百万次的回表查询，速度肯定会很慢，于是我的解决思路是，在“第一步”时不进行回表查询，这样会不会效率提高很多，于是把sql改成下面的等效查询。</p>
<pre><code class="mysql">SELECT    
    *
FROM    
    t_log t RIGHT JOIN (
        SELECT uid
        FROM t_log
        WHERE type = 1
        LIMIT 1000000,50
    ) tmp ON tmp.uid = t.uid

查询时间：0.64</code></pre>
<h2 id="4-优化例子2"><a href="#4-优化例子2" class="headerlink" title="4. 优化例子2"></a>4. 优化例子2</h2><p>SQL1:</p>
<pre><code class="mysql">select 
    brand 
from 
    index_basedata 
where 
    year = 2018 
group by 
    day 
limit 5;</code></pre>
<p>使用了索引“year”, 则索引列为year，但是select brand from..中brand并不是索引列，就需要回表。</p>
<p>通过explain发现进行了table_scan，然后IndexLookUp进行了回表</p>
<p>SQL2:</p>
<pre><code class="mysql">select 
    brand 
from 
    index_basedata 
where 
    year = 2018 
group by 
    year 
limit 5;</code></pre>
<p>使用了索引“year”, 则索引列为year，但是select brand from..中brand并不是索引列，就需要回表（通过图也可以看出，进行了tablescan,另外其中的IndexLookUp也说明了进行了回表），所以花费时间长.</p>
<p>另外，对于sql2中的group by使用的是索引列，所以使用的StreamAgg，不同于sql1</p>
<p>SQL3:</p>
<pre><code class="MYSQL">select 
    year 
from 
    index_basedata 
where 
    year = 2018 
group by 
    year 
limit 5;</code></pre>
<p>没有tablescan，也没有使用IndexLookUp而是IndexReader说明直接从索引中读取索引列并使用。</p>
<p><strong>在上述案例中，sql3使用了索引列，没有进行回表，sql1与sql2进行了回表，所以花费时间长。所以说，发生严重的回表的时候，查询速度比不使用索引还慢。</strong></p>
<p>SQL1  2执行的时间（20s+）是SQL3（2s）的10倍以上</p>
<h1 id="分库分表（高并发层面数据库应该如何设计）"><a href="#分库分表（高并发层面数据库应该如何设计）" class="headerlink" title="分库分表（高并发层面数据库应该如何设计）"></a>分库分表（高并发层面数据库应该如何设计）</h1><p>分库分表是两个概念，可能只分库或者只分表。</p>
<p>如果说到高并发，肯定需要提到一点就是分库分表</p>
<h2 id="1-分库"><a href="#1-分库" class="headerlink" title="1. 分库"></a>1. 分库</h2><p><strong>单表数据量太大</strong>，会极大影响你的 sql <strong>执行的性能</strong>，到了后面你的 sql 可能就跑的很慢了。一般来说，就以我的经验来看，单表到几百万的时候，性能就会相对差一些了，你就得分表了。</p>
<p>分表就是将同一个表中的记录拆分到多个结构相同的表中，然后查询的时候你就查一个表。</p>
<p>比如按照用户 id 来分表，将一个用户的数据就放在一个表中。然后操作的时候你对一个用户就操作那个表就好了。这样可以控制每个表的数据量在可控的范围内，比如每个表就固定在 200 万以内。</p>
<h2 id="2-分表"><a href="#2-分表" class="headerlink" title="2. 分表"></a>2. 分表</h2><p>将一个库的数据拆分到多个库中，访问的时候就访问一个库好了。</p>
<h2 id="3-水平拆分与垂直拆分"><a href="#3-水平拆分与垂直拆分" class="headerlink" title="3. 水平拆分与垂直拆分"></a>3. 水平拆分与垂直拆分</h2><ul>
<li><strong>水平拆分</strong>的意思，就是把一个表的数据给弄到多个库的多个表里去，但是每个库的表结构都一样，只不过每个库表放的数据是不同的，所有库表的数据加起来就是全部数据。水平拆分的意义，就是将数据均匀放更多的库里，然后用多个库来扛更高的并发，还有就是用多个库的存储容量来进行扩容。</li>
<li><strong>垂直拆分</strong>的意思，就是<strong>把一个有很多字段的表给拆分成多个表</strong>，<strong>或者是多个库上去</strong>。每个库表的结构都不一样，每个库表都包含部分字段。一般来说，会<strong>将较少的访问频率很高的字段放到一个表里去</strong>，然后<strong>将较多的访问频率很低的字段放到另外一个表里去</strong>。因为数据库是有缓存的，你访问频率高的行字段越少，就可以在缓存里缓存更多的行，性能就越好。这个一般在表层面做的较多一些。</li>
</ul>
<p><strong>水平切分的问题</strong></p>
<ul>
<li>分布式事务问题：使用分布式事务来解决</li>
<li>ID唯一性问题：使用全局唯一ID，为每一个分片指定一个ID范围，分布式ID生成器（如雪花算法）</li>
</ul>
<p><strong>分库分表的方式</strong></p>
<ul>
<li>一种是按照 range 来分，就是每个库一段连续的数据，这个一般是按比如<strong>时间范围</strong>来的，但是这种一般较少用，因为很容易产生热点问题，大量的流量都打在最新的数据上了。</li>
<li>或者是按照某个字段 hash 一下均匀分散，这个较为常用。坏处在于说<strong>扩容起来比较麻烦</strong>，会有一个数据迁移的过程，之前的数据需要重新计算 hash 值重新分配到不同的库或表。</li>
</ul>
<h1 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h1><p>就是基于主从复制架构，简单来说，就搞一个主库，挂多个从库，然后我们就单单只是写主库，然后主库会自动把数据给同步到从库上去。</p>
<h2 id="1-主从复制过程"><a href="#1-主从复制过程" class="headerlink" title="1. 主从复制过程"></a>1. 主从复制过程</h2><p>主库将变更写入 binlog 日志，然后从库连接到主库之后，从库有一个 IO 线程，将主库的 binlog 日志拷贝到自己本地，写入一个中继日志中。接着从库中有一个 SQL 线程会从中继日志读取 binlog，然后执行 binlog 日志中的内容，也就是在自己本地再次执行一遍 SQL，这样就可以保证自己跟主库的数据是一样的。</p>
<h2 id="2-主从同步延时问题"><a href="#2-主从同步延时问题" class="headerlink" title="2. 主从同步延时问题"></a>2. 主从同步延时问题</h2><p>这里有一个非常重要的一点，就是从库同步主库数据的过程是<strong>串行化</strong>的，也就是说主库上并行的操作，在从库上会串行执行。所以这就是一个非常重要的点了，由于从库从主库拷贝日志以及串行执行 SQL 的特点，<strong>在高并发场景下，从库的数据一定会比主库慢一些，是有延时</strong>的。所以经常出现刚写入主库的数据可能是读不到的，要过几十毫秒，甚至几百毫秒才能读取到。</p>
<p>可以通过<strong>并行复制</strong>的机制来解决主从同步的延时问题。所谓<strong>并行复制</strong>，指的是从库开启多个线程，并行读取 relay log 中不同库的日志，然后<strong>并行重放不同库的日志</strong>，这是库级别的并行。</p>
<h2 id="3-主库宕机问题"><a href="#3-主库宕机问题" class="headerlink" title="3. 主库宕机问题"></a>3. 主库宕机问题</h2><p>而且这里还有另外一个问题，就是如果主库突然宕机，然后恰好数据还没同步到从库，那么有些数据可能在从库上是没有的，有些数据可能就丢失了。</p>
<p>可以通过半同步复制来解决主库宕机的问题。这个所谓<strong>半同步复制</strong>，指的就是主库写入 binlog 日志之后，就会将<strong>强制</strong>此时立即将数据同步到从库，从库将日志写入自己本地的 relay log 之后，接着会返回一个 ack 给主库，主库接收到<strong>至少一个从库</strong>的 ack 之后才会认为写操作完成了。</p>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="1-char与varchar的区别"><a href="#1-char与varchar的区别" class="headerlink" title="1. char与varchar的区别"></a>1. char与varchar的区别</h2><ol>
<li><p>char的长度是固定的，varchar2的长度是可变的。</p>
<p>例如：要存储字符串”abc”，对于char(10)，表示存储的字符将占10个字节，其中有7个字节是空的，但依然需要占这个空间。varchar(10)，则只占用了3个字节的长度，10只是最大值，当存储的字符长度小于10时，会按照实际的长度存储</p>
</li>
<li><p>char的效率比varchar2的效率更高</p>
<p>varchar2比char更省空间，但是在效率上char会更高一些。</p>
</li>
</ol>
<h2 id="2-一行数据中的多个NULL字段在磁盘如何存储"><a href="#2-一行数据中的多个NULL字段在磁盘如何存储" class="headerlink" title="2. 一行数据中的多个NULL字段在磁盘如何存储"></a>2. 一行数据中的多个NULL字段在磁盘如何存储</h2><h1 id="热备份和冷备份"><a href="#热备份和冷备份" class="headerlink" title="热备份和冷备份"></a>热备份和冷备份</h1><ol>
<li><p><strong>冷备份</strong></p>
<p>冷备份发生在数据库已经关闭的情况下，当正常关闭时会提供一个完整的数据库，冷备份就是将关键性文件拷贝到另一个位置的一种说法。对于备份数据库信息而言，冷备份是最快最安全的一种方式</p>
<ul>
<li><strong>优点</strong>：<ol>
<li>快速，只需要拷贝文件</li>
<li>容易归档，只需要简单拷贝即可</li>
<li>容易恢复到某个时间节点上</li>
<li>能与归档的方式相结合，作为数据库最新状态的恢复</li>
<li>低度维护，高度安全</li>
</ol>
</li>
<li><strong>缺点</strong>：<ol>
<li>单独使用时，只能提供到某一个时间点上的恢复</li>
<li>在实施备份的全过程中，数据库必须用作备份，不能用于其他工作，也就是说，必须在关闭的情况下才可以冷备份</li>
<li>若磁盘的空间有限，只能拷贝到其他的存储设备上，速度会很慢</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>热备份</strong></p>
<p>在数据库运行的情况下，备份数据库操作的SQL语句，当数据库发生问题时，可以重新执行一遍备份的SQL语句</p>
<ul>
<li><strong>优点</strong>：<ol>
<li>可以在已经有一个数据库的情况下备份，备份的时间短</li>
<li>备份的时候数据库依然可用</li>
<li>可以在秒级时间恢复到某个时间点</li>
<li>可以对几乎所有的数据库实体作恢复</li>
<li>恢复是快速的，在大多数情况下，在数据库仍工作时恢复</li>
</ol>
</li>
<li><strong>缺点</strong>：<ol>
<li>不能出错</li>
<li>如果热备份不成功，所得的结果不可以用于时间点的恢复</li>
<li>维护困难</li>
</ol>
</li>
</ul>
</li>
</ol>

      
       
    </div>
</article>







    




    </div>
    <div class="copyright">
        <p class="footer-entry">©2019-2020 POWDER SNOW</p>

    </div>
    <div class="full-toc">
        <button class="full"><span class="min "></span></button>
<button class="post-toc-menu"><span class="post-toc-menu-icons"></span></button>
<div class="post-toc"><span class="post-toc-title">目录</span>
    <div class="post-toc-content">

    </div>
</div>
<a class="" id="rocket" ></a>

    </div>
</div>
<div class="acParent"></div>

</body>
<script src="/js/jquery.pjax.js?v=1.0.1" ></script>

<script src="/js/script.js?v=1.0.1" ></script>
<script>
    var img_resize = 'default';
    /*作者、标签的自动补全*/
    $(function () {
        $('.search').AutoComplete({
            'data': ['#HTTP','#protobuf','#MySQL SQL','#Spring','#java','#QT','#区块链','#分布式','#大数据','#前端','#MyBatis','#SpringBoot','#网络编程','#Redis','#多线程','#数据库',],
            'itemHeight': 20,
            'width': 418
        }).AutoComplete('show');
    })
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $(".post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        

        /*高亮代码块行号*/
        

        /*访问数量*/
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    

</script>

<!--加入行号的高亮代码块样式-->

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 544px;
    }
    .nav.fullscreen {
        margin-left: -544px;
    }
    .nav-left {
        width: 122px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
        .nav .hide-list.fullscreen {
            left: 492px
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #fbf4a8;
    }
    
    

    /*列表样式*/
    
    .post .pjax article .article-entry>ol, .post .pjax article .article-entry>ul, .post .pjax article>ol, .post .pjax article>ul{
        border: #e2dede solid 1px;
        border-radius: 10px;
        padding: 10px 32px 10px 56px;
    }
    .post .pjax article .article-entry li>ol, .post .pjax article .article-entry li>ul,.post .pjax article li>ol, .post .pjax article li>ul{
        padding-top: 5px;
        padding-bottom: 5px;
    }
    .post .pjax article .article-entry>ol>li, .post .pjax article .article-entry>ul>li,.post .pjax article>ol>li, .post .pjax article>ul>li{
        margin-bottom: auto;
        margin-left: auto;
    }
    .post .pjax article .article-entry li>ol>li, .post .pjax article .article-entry li>ul>li,.post .pjax article li>ol>li, .post .pjax article li>ul>li{
        margin-bottom: auto;
        margin-left: auto;
    }
    

    /* 背景图样式 */
    
    .post {
        background: url(/img/bck.jpg);
    }
    
    
    .post.index {
        background: url(/img/background.jpg);
    }
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    
    .nav-right:before {
        content: ' ';
        display: block;
        position: absolute;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        opacity: 0.3;
        background: url("/img/123.jpg");
        background-repeat: no-repeat;
        background-position: 50% 0;
        -ms-background-size: cover;
        -o-background-size: cover;
        -moz-background-size: cover;
        -webkit-background-size: cover;
        background-size: cover;
    }
    

    
</style>







</html>
